# botglue.nvim v0.2.0 Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Rewrite botglue.nvim from 4 hardcoded operations to a unified inline editing assistant with extmark progress, Telescope prompt history, and Claude Code project-level context.

**Architecture:** Single command `:Botglue` → Telescope picker (history) → input window (model cycling) → Claude Code `-p` with `stream-json` + `--allowedTools Read,Grep,Glob` → inline extmark progress → replace selection. Modeled after ThePrimeagen/99.

**Tech Stack:** Lua (Neovim plugin), Claude Code CLI, telescope.nvim, Neovim extmarks API.

**Design document:** `docs/plans/2026-02-06-v0.2.0-design.md`

**Reference implementation:** `/home/heliotik/project/heliotik/300/lua/99/` (fork of ThePrimeagen/99)

---

## Phase 1: Foundation

### Task 1: Update config.lua with new defaults

**Files:**
- Modify: `lua/botglue/config.lua`
- Modify: `test/botglue/config_spec.lua`

**Step 1: Write failing tests for new config fields**

Add to `test/botglue/config_spec.lua`:

```lua
it("has models list with opus first", function()
  assert.same({ "opus", "sonnet", "haiku" }, config.defaults.models)
end)

it("has timeout set to 300", function()
  assert.equals(300, config.defaults.timeout)
end)

it("has max_turns set to 3", function()
  assert.equals(3, config.defaults.max_turns)
end)

it("has ai_stdout_rows set to 5", function()
  assert.equals(5, config.defaults.ai_stdout_rows)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/config_spec.lua"`
Expected: FAIL — new fields don't exist yet.

**Step 3: Update config.lua with new defaults**

Replace `lua/botglue/config.lua` contents:

```lua
local M = {}

M.defaults = {
  model = "opus",
  models = { "opus", "sonnet", "haiku" },
  default_keymaps = true,
  timeout = 300,
  max_turns = 3,
  ai_stdout_rows = 5,
}

M.options = {}

function M.setup(opts)
  M.options = vim.tbl_deep_extend("force", {}, M.defaults, opts or {})
end

return M
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/config_spec.lua"`
Expected: ALL PASS.

**Step 5: Commit**

```bash
git add lua/botglue/config.lua test/botglue/config_spec.lua
git commit -m "feat(config): add models, timeout, max_turns, ai_stdout_rows defaults"
```

---

### Task 2: Create display.lua — Mark class

**Files:**
- Create: `lua/botglue/display.lua`
- Create: `test/botglue/display_spec.lua`

**Step 1: Write failing tests for Mark class**

Create `test/botglue/display_spec.lua`:

```lua
describe("botglue.display", function()
  local display

  before_each(function()
    package.loaded["botglue.display"] = nil
    display = require("botglue.display")
  end)

  describe("Mark", function()
    local bufnr

    before_each(function()
      bufnr = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
        "line one",
        "line two",
        "line three",
        "line four",
      })
    end)

    after_each(function()
      vim.api.nvim_buf_delete(bufnr, { force = true })
    end)

    it("creates a mark above a line", function()
      local mark = display.Mark.above(bufnr, 2) -- 1-indexed line
      assert.is_truthy(mark)
      assert.is_true(mark:is_valid())
    end)

    it("creates a mark at a line", function()
      local mark = display.Mark.at(bufnr, 3) -- 1-indexed line
      assert.is_truthy(mark)
      assert.is_true(mark:is_valid())
    end)

    it("sets virtual text on mark", function()
      local mark = display.Mark.at(bufnr, 2)
      -- Should not error
      mark:set_virtual_text({ "spinner line", "status line" })
      assert.is_true(mark:is_valid())
    end)

    it("deletes a mark", function()
      local mark = display.Mark.at(bufnr, 2)
      assert.is_true(mark:is_valid())
      mark:delete()
      assert.is_false(mark:is_valid())
    end)
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/display_spec.lua"`
Expected: FAIL — module doesn't exist.

**Step 3: Implement Mark class**

Create `lua/botglue/display.lua`:

```lua
local nsid = vim.api.nvim_create_namespace("botglue")

--- @class botglue.Mark
--- @field id number
--- @field buffer number
local Mark = {}
Mark.__index = Mark

--- Create extmark above a line (1-indexed).
--- Places mark at end of the line above, so virt_lines appear between lines.
--- @param buffer number
--- @param line number 1-indexed line number
--- @return botglue.Mark
function Mark.above(buffer, line)
  local row = line - 1 -- convert to 0-indexed
  local above = row == 0 and 0 or row - 1
  local col = 0

  if above ~= row then
    local text = vim.api.nvim_buf_get_lines(buffer, above, above + 1, false)[1]
    col = text and #text or 0
  end

  local id = vim.api.nvim_buf_set_extmark(buffer, nsid, above, col, {})
  return setmetatable({ id = id, buffer = buffer }, Mark)
end

--- Create extmark at a line (1-indexed).
--- @param buffer number
--- @param line number 1-indexed line number
--- @return botglue.Mark
function Mark.at(buffer, line)
  local row = line - 1
  local id = vim.api.nvim_buf_set_extmark(buffer, nsid, row, 0, {})
  return setmetatable({ id = id, buffer = buffer }, Mark)
end

--- @return boolean
function Mark:is_valid()
  local pos = vim.api.nvim_buf_get_extmark_by_id(self.buffer, nsid, self.id, {})
  return #pos > 0
end

--- Update virtual text lines on this mark.
--- @param lines string[]
function Mark:set_virtual_text(lines)
  local pos = vim.api.nvim_buf_get_extmark_by_id(self.buffer, nsid, self.id, {})
  if #pos == 0 then
    return
  end
  local row, col = pos[1], pos[2]

  local formatted = {}
  for _, line in ipairs(lines) do
    table.insert(formatted, { { line, "Comment" } })
  end

  vim.api.nvim_buf_set_extmark(self.buffer, nsid, row, col, {
    id = self.id,
    virt_lines = formatted,
  })
end

function Mark:delete()
  pcall(vim.api.nvim_buf_del_extmark, self.buffer, nsid, self.id)
end

return {
  Mark = Mark,
  nsid = nsid,
}
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/display_spec.lua"`
Expected: ALL PASS.

**Step 5: Run lint + format**

Run: `make fmt && make lint`
Expected: Clean.

**Step 6: Commit**

```bash
git add lua/botglue/display.lua test/botglue/display_spec.lua
git commit -m "feat(display): add Mark class with extmark management"
```

---

### Task 3: Add RequestStatus class to display.lua

**Files:**
- Modify: `lua/botglue/display.lua`
- Modify: `test/botglue/display_spec.lua`

**Step 1: Write failing tests for RequestStatus**

Add to `test/botglue/display_spec.lua`:

```lua
describe("RequestStatus", function()
  local bufnr

  before_each(function()
    bufnr = vim.api.nvim_create_buf(false, true)
    vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
      "line one",
      "line two",
    })
  end)

  after_each(function()
    vim.api.nvim_buf_delete(bufnr, { force = true })
  end)

  it("creates a RequestStatus with title", function()
    local mark = display.Mark.at(bufnr, 1)
    local status = display.RequestStatus.new(250, 3, "Processing", mark)
    assert.is_truthy(status)
    assert.equals(false, status.running)
  end)

  it("returns spinner + title from get()", function()
    local mark = display.Mark.at(bufnr, 1)
    local status = display.RequestStatus.new(250, 3, "Processing", mark)
    local lines = status:get()
    assert.equals(1, #lines)
    assert.matches("Processing", lines[1])
  end)

  it("push adds lines and evicts oldest when over max", function()
    local mark = display.Mark.at(bufnr, 1)
    local status = display.RequestStatus.new(250, 3, "Processing", mark)
    status:push("line A")
    status:push("line B")
    status:push("line C") -- max_lines=3, spinner takes 1, so 2 stdout lines max
    local lines = status:get()
    -- spinner + 2 lines (oldest evicted)
    assert.equals(3, #lines)
    assert.matches("line B", lines[2])
    assert.matches("line C", lines[3])
  end)

  it("start and stop control running state", function()
    local mark = display.Mark.at(bufnr, 1)
    local status = display.RequestStatus.new(250, 1, "Processing", mark)
    status:start()
    assert.is_true(status.running)
    status:stop()
    assert.is_false(status.running)
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/display_spec.lua"`
Expected: FAIL — RequestStatus doesn't exist.

**Step 3: Implement RequestStatus**

Add to `lua/botglue/display.lua` before the return statement:

```lua
local braille_chars = { "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" }

--- @class botglue.StatusLine
--- @field index number
--- @field title string
local StatusLine = {}
StatusLine.__index = StatusLine

function StatusLine.new(title)
  return setmetatable({ index = 1, title = title }, StatusLine)
end

function StatusLine:update()
  self.index = self.index + 1
end

--- @return string
function StatusLine:to_string()
  return braille_chars[self.index % #braille_chars + 1] .. " " .. self.title
end

--- @class botglue.RequestStatus
--- @field update_time number
--- @field max_lines number
--- @field status_line botglue.StatusLine
--- @field lines string[]
--- @field running boolean
--- @field mark botglue.Mark
local RequestStatus = {}
RequestStatus.__index = RequestStatus

--- @param update_time number milliseconds between spinner updates
--- @param max_lines number max total lines (spinner + stdout lines)
--- @param title string title shown next to spinner
--- @param mark botglue.Mark
--- @return botglue.RequestStatus
function RequestStatus.new(update_time, max_lines, title, mark)
  return setmetatable({
    update_time = update_time,
    max_lines = max_lines,
    status_line = StatusLine.new(title),
    lines = {},
    running = false,
    mark = mark,
  }, RequestStatus)
end

--- @return string[]
function RequestStatus:get()
  local result = { self.status_line:to_string() }
  for _, line in ipairs(self.lines) do
    table.insert(result, line)
  end
  return result
end

--- @param line string
function RequestStatus:push(line)
  table.insert(self.lines, line)
  if #self.lines > self.max_lines - 1 then
    table.remove(self.lines, 1)
  end
end

function RequestStatus:start()
  self.running = true

  local function update_spinner()
    if not self.running then
      return
    end
    self.status_line:update()
    self.mark:set_virtual_text(self:get())
    vim.defer_fn(update_spinner, self.update_time)
  end

  vim.defer_fn(update_spinner, self.update_time)
end

function RequestStatus:stop()
  self.running = false
end
```

Update the return statement:

```lua
return {
  Mark = Mark,
  RequestStatus = RequestStatus,
  nsid = nsid,
}
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/display_spec.lua"`
Expected: ALL PASS.

**Step 5: Commit**

```bash
git add lua/botglue/display.lua test/botglue/display_spec.lua
git commit -m "feat(display): add RequestStatus with spinner animation"
```

---

### Task 4: Rewrite claude.lua — CLI builder, process management, cancel

**Files:**
- Rewrite: `lua/botglue/claude.lua`
- Rewrite: `test/botglue/claude_spec.lua`

**Step 1: Write failing tests for new claude.lua**

Replace `test/botglue/claude_spec.lua`:

```lua
describe("botglue.claude", function()
  local claude

  before_each(function()
    package.loaded["botglue.claude"] = nil
    package.loaded["botglue.config"] = nil
    local config = require("botglue.config")
    config.setup()
    claude = require("botglue.claude")
  end)

  describe("build_command", function()
    it("builds command with all required flags", function()
      local cmd = claude.build_command("simplify this", {
        filepath = "lua/botglue/config.lua",
        start_line = 5,
        end_line = 10,
        filetype = "lua",
        project = "botglue.nvim",
        model = "opus",
      })
      assert.equals("claude", cmd[1])
      assert.is_truthy(vim.tbl_contains(cmd, "-p"))
      assert.is_truthy(vim.tbl_contains(cmd, "--output-format"))
      assert.is_truthy(vim.tbl_contains(cmd, "--verbose"))
      assert.is_truthy(vim.tbl_contains(cmd, "--allowedTools"))
    end)

    it("includes model flag", function()
      local cmd = claude.build_command("test", {
        filepath = "f.lua",
        start_line = 1,
        end_line = 2,
        filetype = "lua",
        project = "p",
        model = "sonnet",
      })
      local model_idx = nil
      for i, v in ipairs(cmd) do
        if v == "--model" then
          model_idx = i
        end
      end
      assert.is_truthy(model_idx)
      assert.equals("sonnet", cmd[model_idx + 1])
    end)

    it("includes max-turns flag from config", function()
      local cmd = claude.build_command("test", {
        filepath = "f.lua",
        start_line = 1,
        end_line = 2,
        filetype = "lua",
        project = "p",
        model = "opus",
      })
      assert.is_truthy(vim.tbl_contains(cmd, "--max-turns"))
    end)
  end)

  describe("build_system_prompt", function()
    it("includes file path and line range", function()
      local prompt = claude.build_system_prompt({
        filepath = "lua/botglue/config.lua",
        start_line = 5,
        end_line = 10,
        filetype = "lua",
        project = "botglue.nvim",
      })
      assert.matches("lua/botglue/config.lua", prompt)
      assert.matches("5", prompt)
      assert.matches("10", prompt)
      assert.matches("lua", prompt)
      assert.matches("botglue.nvim", prompt)
    end)
  end)

  describe("cancel", function()
    it("does not error when no active job", function()
      assert.has_no.errors(function()
        claude.cancel()
      end)
    end)
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/claude_spec.lua"`
Expected: FAIL — new functions don't exist.

**Step 3: Implement new claude.lua**

Replace `lua/botglue/claude.lua`:

```lua
local config = require("botglue.config")

local M = {}

M._active_job = nil
M._timeout_timer = nil

--- Build the system prompt with file and selection context.
--- @param ctx table {filepath, start_line, end_line, filetype, project}
--- @return string
function M.build_system_prompt(ctx)
  return string.format(
    [[You are an inline code editor inside Neovim.
The user selected a region in file: %s (lines %d-%d).
Filetype: %s. Project: %s.

Read the file if you need surrounding context to understand the code.
Modify ONLY the selected region based on the user's request.
Return ONLY the replacement code — no explanations, no markdown fences, no extra text.
The output will directly replace the selection in the editor.]],
    ctx.filepath,
    ctx.start_line,
    ctx.end_line,
    ctx.filetype,
    ctx.project
  )
end

--- Build the CLI command array.
--- @param prompt string user's prompt text
--- @param ctx table {filepath, start_line, end_line, filetype, project, model}
--- @return string[]
function M.build_command(prompt, ctx)
  local system_prompt = M.build_system_prompt(ctx)
  return {
    "claude",
    "-p",
    prompt,
    "--output-format",
    "stream-json",
    "--verbose",
    "--allowedTools",
    "Read,Grep,Glob",
    "--model",
    ctx.model,
    "--max-turns",
    tostring(config.options.max_turns),
    "--append-system-prompt",
    system_prompt,
  }
end

--- Start a Claude Code request.
--- @param prompt string
--- @param ctx table
--- @param observer table {on_stdout: fn(line), on_complete: fn(err, result)}
function M.start(prompt, ctx, observer)
  if M._active_job and M._active_job > 0 then
    observer.on_complete("Another request is already running", nil)
    return
  end

  local cmd = M.build_command(prompt, ctx)
  local stdout_chunks = {}

  M._active_job = vim.fn.jobstart(cmd, {
    stdout_buffered = false,
    stderr_buffered = false,
    on_stdout = function(_, data)
      if not data then
        return
      end
      for _, line in ipairs(data) do
        if line ~= "" then
          table.insert(stdout_chunks, line)
          -- Try to parse as JSON and extract activity for display
          local ok, parsed = pcall(vim.json.decode, line)
          if ok and parsed then
            if observer.on_stdout then
              observer.on_stdout(parsed)
            end
          end
        end
      end
    end,
    on_stderr = function() end,
    on_exit = function(_, code)
      M._clear_timeout()
      M._active_job = nil

      if code ~= 0 then
        vim.schedule(function()
          observer.on_complete("Claude Code exited with code " .. code, nil)
        end)
        return
      end

      -- Extract final result from stream-json events
      -- The last message with result text is what we need
      vim.schedule(function()
        local result = M._extract_result(stdout_chunks)
        if result and result ~= "" then
          observer.on_complete(nil, result)
        else
          observer.on_complete("Empty response from Claude", nil)
        end
      end)
    end,
  })

  if M._active_job <= 0 then
    M._active_job = nil
    observer.on_complete("Failed to start Claude process", nil)
    return
  end

  -- Start timeout timer
  M._start_timeout(config.options.timeout)
end

--- Extract the final text result from stream-json chunks.
--- This is a research-dependent function — the exact JSON structure
--- needs to be confirmed during research task #1.
--- @param chunks string[]
--- @return string|nil
function M._extract_result(chunks)
  -- Strategy: parse each chunk as JSON, look for the final result.
  -- stream-json format delivers events; the last "result" type event
  -- or accumulated text_delta events contain the answer.
  -- RESEARCH NOTE: This implementation will be refined after testing
  -- stream-json output format. For now, try common patterns.
  local result_parts = {}

  for _, chunk in ipairs(chunks) do
    local ok, parsed = pcall(vim.json.decode, chunk)
    if ok and parsed then
      -- Pattern 1: final result event
      if parsed.result then
        return parsed.result
      end
      -- Pattern 2: text delta accumulation
      if
        parsed.type == "stream_event"
        and parsed.event
        and parsed.event.delta
        and parsed.event.delta.type == "text_delta"
      then
        table.insert(result_parts, parsed.event.delta.text)
      end
    end
  end

  if #result_parts > 0 then
    return table.concat(result_parts, "")
  end

  -- Fallback: try to parse the last non-empty chunk as plain JSON with result
  for i = #chunks, 1, -1 do
    local ok, parsed = pcall(vim.json.decode, chunks[i])
    if ok and parsed and parsed.result then
      return parsed.result
    end
  end

  return nil
end

function M.cancel()
  if M._active_job and M._active_job > 0 then
    vim.fn.jobstop(M._active_job)
    M._active_job = nil
  end
  M._clear_timeout()
end

--- @param timeout_sec number
function M._start_timeout(timeout_sec)
  M._clear_timeout()
  M._timeout_timer = vim.uv.new_timer()
  M._timeout_timer:start(timeout_sec * 1000, 0, vim.schedule_wrap(function()
    if M._active_job then
      M.cancel()
      vim.notify("botglue: request timed out", vim.log.levels.WARN)
    end
  end))
end

function M._clear_timeout()
  if M._timeout_timer then
    M._timeout_timer:stop()
    M._timeout_timer:close()
    M._timeout_timer = nil
  end
end

return M
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/claude_spec.lua"`
Expected: ALL PASS.

**Step 5: Run lint + format**

Run: `make fmt && make lint`
Expected: Clean.

**Step 6: Commit**

```bash
git add lua/botglue/claude.lua test/botglue/claude_spec.lua
git commit -m "feat(claude): rewrite with stream-json, allowedTools, cancel, timeout"
```

---

### Task 5: Simplify operations.lua — single flow, always replace

**Files:**
- Modify: `lua/botglue/operations.lua`

**Step 1: Rewrite operations.lua**

Remove `ResultMode`, `get_context()`, and the old `run()`. Keep `get_visual_selection()` and `replace_selection()`. Add new `run()` that takes prompt + model and orchestrates display + claude.

```lua
local display = require("botglue.display")
local claude = require("botglue.claude")
local config = require("botglue.config")

local M = {}

function M.get_visual_selection()
  local start_pos = vim.fn.getpos("'<")
  local end_pos = vim.fn.getpos("'>")

  local start_line = start_pos[2]
  local end_line = end_pos[2]

  if start_line == 0 or end_line == 0 then
    return nil
  end

  local is_linewise = end_pos[3] >= 2147483647 or start_pos[3] >= 2147483647

  local start_col, end_col

  if is_linewise then
    start_col = 0
    local end_line_content = vim.api.nvim_buf_get_lines(0, end_line - 1, end_line, false)[1]
    end_col = end_line_content and #end_line_content or 0
  else
    start_col = start_pos[3] - 1
    end_col = end_pos[3]

    local end_line_content = vim.api.nvim_buf_get_lines(0, end_line - 1, end_line, false)[1]
    if end_line_content then
      end_col = math.min(end_col, #end_line_content)
    end
  end

  local ok, lines =
    pcall(vim.api.nvim_buf_get_text, 0, start_line - 1, start_col, end_line - 1, end_col, {})

  if not ok then
    return nil
  end

  return {
    text = table.concat(lines, "\n"),
    bufnr = vim.api.nvim_get_current_buf(),
    start_line = start_line,
    start_col = start_col,
    end_line = end_line,
    end_col = end_col,
  }
end

function M.replace_selection(sel, new_text)
  local lines = vim.split(new_text, "\n")

  local ok, err = pcall(
    vim.api.nvim_buf_set_text,
    sel.bufnr,
    sel.start_line - 1,
    sel.start_col,
    sel.end_line - 1,
    sel.end_col,
    lines
  )

  if not ok then
    vim.notify("botglue: failed to replace text: " .. tostring(err), vim.log.levels.ERROR)
  end
end

--- Main entry point. Called after user submits prompt from input window.
--- @param prompt string user's prompt text
--- @param model string model to use
function M.run(prompt, model)
  local sel = M.get_visual_selection()
  if not sel or sel.text == "" then
    vim.notify("botglue: no text selected", vim.log.levels.WARN)
    return
  end

  local bufnr = sel.bufnr
  local top_mark = display.Mark.above(bufnr, sel.start_line)
  local bottom_mark = display.Mark.at(bufnr, sel.end_line)

  local top_status = display.RequestStatus.new(
    250,
    config.options.ai_stdout_rows,
    "Processing",
    top_mark
  )
  local bottom_status = display.RequestStatus.new(250, 1, "Processing", bottom_mark)

  local cleaned_up = false
  local function cleanup()
    if cleaned_up then
      return
    end
    cleaned_up = true
    top_status:stop()
    bottom_status:stop()
    top_mark:delete()
    bottom_mark:delete()
  end

  -- Store cleanup for external cancel
  M._cleanup = cleanup

  top_status:start()
  bottom_status:start()

  local ctx = {
    filepath = vim.fn.expand("%:."),
    start_line = sel.start_line,
    end_line = sel.end_line,
    filetype = vim.bo.filetype,
    project = vim.fn.fnamemodify(vim.fn.getcwd(), ":t"),
    model = model,
  }

  claude.start(prompt, ctx, {
    on_stdout = function(parsed)
      -- Push activity lines to top extmark
      -- RESEARCH NOTE: exact event parsing depends on stream-json format
      if parsed.type == "stream_event" and parsed.event then
        local delta = parsed.event.delta
        if delta and delta.type == "tool_use" then
          top_status:push("Using " .. (delta.name or "tool") .. "...")
        end
      end
    end,
    on_complete = function(err, result)
      vim.schedule(function()
        cleanup()
        if err then
          vim.notify("botglue: " .. err, vim.log.levels.ERROR)
          return
        end
        M.replace_selection(sel, result)
        vim.notify("botglue: done", vim.log.levels.INFO)
      end)
    end,
  })
end

function M.cancel()
  claude.cancel()
  if M._cleanup then
    M._cleanup()
    M._cleanup = nil
  end
  vim.notify("botglue: cancelled", vim.log.levels.WARN)
end

return M
```

**Step 2: Run lint + format**

Run: `make fmt && make lint`
Expected: Clean.

**Step 3: Commit**

```bash
git add lua/botglue/operations.lua
git commit -m "feat(operations): simplify to single run flow, always replace"
```

---

## Phase 2: Input Flow

### Task 6: Create history.lua — JSON persistence

**Files:**
- Create: `lua/botglue/history.lua`
- Create: `test/botglue/history_spec.lua`

**Step 1: Write failing tests**

Create `test/botglue/history_spec.lua`:

```lua
describe("botglue.history", function()
  local history
  local test_path

  before_each(function()
    package.loaded["botglue.history"] = nil
    history = require("botglue.history")
    test_path = vim.fn.tempname() .. "/botglue-test/history.json"
    history._path = test_path
  end)

  after_each(function()
    pcall(os.remove, test_path)
  end)

  it("starts with empty history", function()
    assert.same({}, history.get_sorted())
  end)

  it("adds a new entry", function()
    history.add("simplify this", "opus")
    local entries = history.get_sorted()
    assert.equals(1, #entries)
    assert.equals("simplify this", entries[1].prompt)
    assert.equals("opus", entries[1].model)
    assert.equals(1, entries[1].count)
  end)

  it("increments count for duplicate prompt", function()
    history.add("simplify this", "opus")
    history.add("simplify this", "opus")
    local entries = history.get_sorted()
    assert.equals(1, #entries)
    assert.equals(2, entries[1].count)
  end)

  it("updates model when reusing prompt with different model", function()
    history.add("simplify this", "opus")
    history.add("simplify this", "sonnet")
    local entries = history.get_sorted()
    assert.equals(1, #entries)
    assert.equals("sonnet", entries[1].model)
  end)

  it("sorts by count descending", function()
    history.add("rare prompt", "opus")
    history.add("frequent prompt", "opus")
    history.add("frequent prompt", "opus")
    history.add("frequent prompt", "opus")
    local entries = history.get_sorted()
    assert.equals("frequent prompt", entries[1].prompt)
    assert.equals("rare prompt", entries[2].prompt)
  end)

  it("saves and loads from disk", function()
    history.add("test prompt", "haiku")
    history.save()

    -- Reset in-memory state
    package.loaded["botglue.history"] = nil
    history = require("botglue.history")
    history._path = test_path
    history.load()

    local entries = history.get_sorted()
    assert.equals(1, #entries)
    assert.equals("test prompt", entries[1].prompt)
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/history_spec.lua"`
Expected: FAIL.

**Step 3: Implement history.lua**

Create `lua/botglue/history.lua`:

```lua
local M = {}

M._entries = {}
M._path = nil

--- Get the history file path.
--- @return string
function M._get_path()
  if M._path then
    return M._path
  end
  local data_dir = vim.fn.stdpath("data")
  return data_dir .. "/botglue/history.json"
end

function M.load()
  local path = M._get_path()
  local f = io.open(path, "r")
  if not f then
    M._entries = {}
    return
  end
  local content = f:read("*a")
  f:close()
  local ok, parsed = pcall(vim.json.decode, content)
  if ok and type(parsed) == "table" then
    M._entries = parsed
  else
    M._entries = {}
  end
end

function M.save()
  local path = M._get_path()
  local dir = vim.fn.fnamemodify(path, ":h")
  vim.fn.mkdir(dir, "p")
  local f = io.open(path, "w")
  if not f then
    return
  end
  f:write(vim.json.encode(M._entries))
  f:close()
end

--- Add or update a history entry.
--- @param prompt string
--- @param model string
function M.add(prompt, model)
  for _, entry in ipairs(M._entries) do
    if entry.prompt == prompt then
      entry.count = entry.count + 1
      entry.model = model
      entry.last_used = os.time()
      M.save()
      return
    end
  end
  table.insert(M._entries, {
    prompt = prompt,
    model = model,
    count = 1,
    last_used = os.time(),
  })
  M.save()
end

--- Return entries sorted by count descending.
--- @return table[]
function M.get_sorted()
  local sorted = vim.deepcopy(M._entries)
  table.sort(sorted, function(a, b)
    return a.count > b.count
  end)
  return sorted
end

return M
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/history_spec.lua"`
Expected: ALL PASS.

**Step 5: Commit**

```bash
git add lua/botglue/history.lua test/botglue/history_spec.lua
git commit -m "feat(history): add JSON persistence with frequency sorting"
```

---

### Task 7: Create picker.lua — Telescope integration

**Files:**
- Create: `lua/botglue/picker.lua`

**Step 1: Implement picker.lua**

Note: Telescope pickers are hard to unit test — they require full Neovim UI. This module will be tested manually and via integration.

Create `lua/botglue/picker.lua`:

```lua
local history = require("botglue.history")

local M = {}

--- Open Telescope picker with prompt history.
--- @param on_select fun(entry: {prompt: string, model: string}|nil)
function M.open(on_select)
  local ok, pickers = pcall(require, "telescope.pickers")
  if not ok then
    vim.notify("botglue: telescope.nvim is required", vim.log.levels.ERROR)
    return
  end

  local finders = require("telescope.finders")
  local conf = require("telescope.config").values
  local actions = require("telescope.actions")
  local action_state = require("telescope.actions.state")
  local entry_display = require("telescope.pickers.entry_display")

  local entries = history.get_sorted()

  local displayer = entry_display.create({
    separator = " ",
    items = {
      { remaining = true },
      { width = 10 },
    },
  })

  local function make_display(entry)
    return displayer({
      entry.value.prompt,
      { "[" .. entry.value.model .. "]", "Comment" },
    })
  end

  pickers
    .new({}, {
      prompt_title = "Botglue",
      finder = finders.new_table({
        results = entries,
        entry_maker = function(entry)
          return {
            value = entry,
            display = make_display,
            ordinal = entry.prompt,
          }
        end,
      }),
      sorter = conf.generic_sorter({}),
      attach_mappings = function(prompt_bufnr, map)
        actions.select_default:replace(function()
          local selection = action_state.get_selected_entry()
          local current_line = action_state.get_current_line()
          actions.close(prompt_bufnr)

          if selection then
            on_select({ prompt = selection.value.prompt, model = selection.value.model })
          elseif current_line and current_line ~= "" then
            on_select({ prompt = current_line, model = nil })
          else
            on_select(nil)
          end
        end)
        return true
      end,
    })
    :find()
end

return M
```

**Step 2: Run lint + format**

Run: `make fmt && make lint`
Expected: Clean.

**Step 3: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): add Telescope integration with history display"
```

---

### Task 8: Rewrite ui.lua — input window with model badge

**Files:**
- Rewrite: `lua/botglue/ui.lua`

**Step 1: Rewrite ui.lua**

Remove `start_spinner`, `stop_spinner`, `show_result_window`. Rewrite `capture_input` with model badge and cycling.

```lua
local config = require("botglue.config")

local M = {}

--- Open input window with model badge and cycling.
--- @param opts {prompt: string|nil, model: string|nil}
--- @param on_submit fun(prompt: string, model: string)
--- @param on_cancel fun()|nil
function M.capture_input(opts, on_submit, on_cancel)
  opts = opts or {}
  local current_model = opts.model or config.options.model
  local models = config.options.models

  local ui_info = vim.api.nvim_list_uis()[1]
  local width = math.floor(ui_info.width * 2 / 3)
  local height = 3
  local row = math.floor((ui_info.height - height) / 2)
  local col = math.floor((ui_info.width - width) / 2)

  local buf = vim.api.nvim_create_buf(false, true)

  local function make_title()
    return " botglue "
  end

  local function make_footer()
    return " [" .. current_model .. "] "
  end

  local win = vim.api.nvim_open_win(buf, true, {
    relative = "editor",
    width = width,
    height = height,
    row = row,
    col = col,
    style = "minimal",
    border = "rounded",
    title = make_title(),
    title_pos = "left",
    footer = make_footer(),
    footer_pos = "right",
  })

  vim.bo[buf].bufhidden = "wipe"
  vim.wo[win].wrap = true

  -- Pre-fill prompt if provided
  if opts.prompt and opts.prompt ~= "" then
    local lines = vim.split(opts.prompt, "\n")
    vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)
  end

  local function close_window()
    if vim.api.nvim_win_is_valid(win) then
      vim.api.nvim_win_close(win, true)
    end
  end

  local function submit()
    local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
    local input = vim.trim(table.concat(lines, "\n"))
    close_window()
    if input ~= "" then
      on_submit(input, current_model)
    elseif on_cancel then
      on_cancel()
    end
  end

  local function newline()
    local cursor_row, cursor_col = unpack(vim.api.nvim_win_get_cursor(win))
    local line = vim.api.nvim_buf_get_lines(buf, cursor_row - 1, cursor_row, false)[1]
    local before = line:sub(1, cursor_col)
    local after = line:sub(cursor_col + 1)
    vim.api.nvim_buf_set_lines(buf, cursor_row - 1, cursor_row, false, { before, after })
    vim.api.nvim_win_set_cursor(win, { cursor_row + 1, 0 })
  end

  local function cycle_model()
    local idx = 1
    for i, m in ipairs(models) do
      if m == current_model then
        idx = i
        break
      end
    end
    idx = (idx % #models) + 1
    current_model = models[idx]
    -- Update footer with new model
    vim.api.nvim_win_set_config(win, {
      footer = make_footer(),
      footer_pos = "right",
    })
  end

  local function cancel()
    close_window()
    if on_cancel then
      on_cancel()
    end
  end

  vim.keymap.set("i", "<CR>", submit, { buffer = buf, nowait = true })
  vim.keymap.set("n", "<CR>", submit, { buffer = buf, nowait = true })
  vim.keymap.set("i", "<S-CR>", newline, { buffer = buf, nowait = true })
  -- Model cycling: <C-s> because <C-m> = <CR> in terminal
  vim.keymap.set("i", "<C-s>", cycle_model, { buffer = buf, nowait = true })
  vim.keymap.set("n", "<C-s>", cycle_model, { buffer = buf, nowait = true })
  vim.keymap.set("n", "q", cancel, { buffer = buf, nowait = true })
  vim.keymap.set("n", "<Esc>", cancel, { buffer = buf, nowait = true })

  vim.cmd("startinsert")
end

return M
```

**Step 2: Run lint + format**

Run: `make fmt && make lint`
Expected: Clean.

**Step 3: Commit**

```bash
git add lua/botglue/ui.lua
git commit -m "feat(ui): rewrite input window with model badge and cycling"
```

---

## Phase 3: Integration

### Task 9: Rewrite init.lua — setup, run, cancel

**Files:**
- Rewrite: `lua/botglue/init.lua`

**Step 1: Rewrite init.lua**

```lua
local config = require("botglue.config")
local operations = require("botglue.operations")
local history = require("botglue.history")
local picker = require("botglue.picker")
local ui = require("botglue.ui")

local M = {}

function M.setup(opts)
  config.setup(opts)
  history.load()

  if config.options.default_keymaps then
    vim.keymap.set("x", "<leader>pp", function()
      M.run()
    end, { desc = "Botglue: run", silent = true })
    vim.keymap.set("x", "<leader>ps", function()
      M.cancel()
    end, { desc = "Botglue: cancel", silent = true })
  end
end

function M.run()
  picker.open(function(entry)
    if not entry then
      -- Empty selection, open blank input
      ui.capture_input({}, function(prompt, model)
        history.add(prompt, model)
        operations.run(prompt, model)
      end)
      return
    end

    ui.capture_input({
      prompt = entry.prompt,
      model = entry.model,
    }, function(prompt, model)
      history.add(prompt, model)
      operations.run(prompt, model)
    end)
  end)
end

function M.cancel()
  operations.cancel()
end

return M
```

**Step 2: Commit**

```bash
git add lua/botglue/init.lua
git commit -m "feat(init): rewrite with unified run/cancel flow"
```

---

### Task 10: Rewrite plugin/botglue.lua — new commands

**Files:**
- Rewrite: `plugin/botglue.lua`

**Step 1: Rewrite plugin file**

```lua
if vim.g.loaded_botglue then
  return
end
vim.g.loaded_botglue = true

vim.api.nvim_create_user_command("Botglue", function()
  require("botglue").run()
end, { range = true, desc = "Run botglue inline editor" })

vim.api.nvim_create_user_command("BotglueCancel", function()
  require("botglue").cancel()
end, { desc = "Cancel botglue request" })
```

**Step 2: Commit**

```bash
git add plugin/botglue.lua
git commit -m "feat(plugin): replace 4 commands with Botglue and BotglueCancel"
```

---

### Task 11: Clean up — remove all v0.1.0 legacy code

**Files:**
- Verify: all old code is already replaced in previous tasks

**Step 1: Verify no legacy references remain**

Run: `grep -r "ResultMode\|show_result_window\|PROMPTS\|build_prompt\|optimize\|explain\|refactor\|translate\|BotglueOptimize\|BotglueExplain\|BotglueRefactor\|BotglueTranslate" lua/ plugin/`

Expected: No matches (all legacy code removed in Tasks 4-5, 8-10).

**Step 2: Run make pr-ready**

Run: `make pr-ready`
Expected: lint + test + fmt-check all pass.

**Step 3: Commit any remaining cleanup**

```bash
git add -A
git commit -m "chore: remove remaining v0.1.0 legacy references"
```

---

## Phase 4: Testing & Polish

### Task 12: Update tests for new architecture

**Files:**
- Modify: `test/botglue/config_spec.lua` (already updated in Task 1)
- Modify: `test/botglue/claude_spec.lua` (already updated in Task 4)
- Verify: `test/botglue/display_spec.lua` (created in Tasks 2-3)
- Verify: `test/botglue/history_spec.lua` (created in Task 6)

**Step 1: Run full test suite**

Run: `make test`
Expected: ALL PASS.

**Step 2: Run make pr-ready**

Run: `make pr-ready`
Expected: All checks pass.

**Step 3: Commit**

```bash
git commit -m "test: verify all tests pass for v0.2.0 architecture" --allow-empty
```

---

### Task 13: Update README.md

**Files:**
- Modify: `README.md`

**Step 1: Update README to reflect v0.2.0**

Key changes:
- Requirements: add `telescope.nvim`
- Installation: add telescope dependency to lazy.nvim/packer config
- Configuration: new fields (models, timeout, max_turns, ai_stdout_rows)
- Usage: single command `:Botglue`, two keymaps (`<leader>pp`, `<leader>ps`)
- Remove the 4-operation table, replace with unified flow description
- Update input window controls: add `<C-s>` for model cycling
- Remove "Custom Keymaps" section for old keymaps, add new ones

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: update README for v0.2.0 architecture"
```

---

### Task 14: Update CLAUDE.md

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Update CLAUDE.md**

Key changes:
- Update Architecture section with new module list (display.lua, history.lua, picker.lua)
- Update Data Flow diagram
- Update commands list (`:Botglue`, `:BotglueCancel`)
- Add telescope.nvim to dependencies

**Step 2: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md for v0.2.0 architecture"
```

---

### Task 15: Final pr-ready check

**Step 1: Run make pr-ready**

Run: `make pr-ready`
Expected: All checks pass.

**Step 2: Update CHANGELOG.md**

Add v0.2.0 entry above v0.1.0.

**Step 3: Final commit**

```bash
git add CHANGELOG.md
git commit -m "docs: add v0.2.0 to CHANGELOG"
```
