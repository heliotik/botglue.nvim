# v0.2.0 Test Coverage Design

## Goal

Add test coverage for untested v0.2.0 modules: `operations.lua` (unit tests + mocked integration) and `ui.lua` (extracted pure logic). Bring total test count from 34 to ~60.

## Scope

### In scope

- **`operations_spec.lua`** — 18 tests covering `get_visual_selection()`, `replace_selection()`, `run()` with mocked claude, `cancel()`
- **`ui_spec.lua`** — 8 tests covering extracted `_next_model()` and `_resolve_input()` helpers

### Out of scope (future)

- `picker.lua` (requires Telescope mocking)
- `init.lua` integration tests (requires full plugin lifecycle)
- `ui.lua` window/keymap tests (requires UI environment)

## Architecture

### Mocking Strategy

`operations.run()` depends on `claude.start()` and `display.Mark`. We replace modules via `package.loaded` in `before_each`:

```lua
local mock_claude
before_each(function()
  mock_claude = {
    start = function(prompt, ctx, observer)
      mock_claude._last_observer = observer
      mock_claude._last_ctx = ctx
    end,
    cancel = function()
      mock_claude._cancelled = true
    end,
    _cancelled = false,
  }
  package.loaded["botglue.claude"] = mock_claude
end)
```

This lets us invoke `observer.on_complete(nil, result)` or `observer.on_complete("error", nil)` synchronously.

### ui.lua Refactor

Extract two pure functions from `capture_input()` closures:

```lua
function M._next_model(current, models)
  local idx = 1
  for i, m in ipairs(models) do
    if m == current then idx = i break end
  end
  return models[(idx % #models) + 1]
end

function M._resolve_input(text, on_submit, on_cancel, model)
  local input = vim.trim(text)
  if input ~= "" then
    on_submit(input, model)
  elseif on_cancel then
    on_cancel()
  end
end
```

The closures inside `capture_input()` then delegate to these helpers. No behavior change.

### Buffer Setup Pattern

Consistent with existing `display_spec.lua`:

```lua
local bufnr
before_each(function()
  bufnr = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
    "line one", "line two", "line three", "line four",
  })
end)
after_each(function()
  vim.api.nvim_buf_delete(bufnr, { force = true })
end)
```

## Test Plan

### operations_spec.lua (18 tests)

**get_visual_selection():**

1. Returns nil when no marks set
2. Charwise selection — single line
3. Charwise selection — multi-line
4. Linewise selection (col = 2147483647)
5. Explicit bufnr parameter

**replace_selection():**

6. Single-line replacement
7. Multi-line replacement
8. Shrinking replacement (3 lines -> 1 line)
9. Invalid buffer — no crash

**run():**

10. Returns early on nil selection
11. Returns early on empty text
12. Builds correct context (filepath, filetype, model, line range)
13. Calls replace_selection on success
14. Shows error notification on failure
15. Cleanup removes extmarks on complete

**cancel():**

16. Calls claude.cancel()
17. Runs cleanup function
18. Handles no active cleanup (M._cleanup = nil)

### ui_spec.lua (8 tests)

**_next_model():**

19. Cycles opus -> sonnet
20. Cycles haiku -> opus (wraps around)
21. Single model list returns same model
22. Unknown model defaults to second element

**_resolve_input():**

23. Non-empty text calls on_submit with trimmed text and model
24. Whitespace-only text calls on_cancel
25. Empty text with nil on_cancel — no crash
26. Multi-line text passed as single joined string

## Files

```
lua/botglue/ui.lua                    (modify — extract 2 helpers)
test/botglue/operations_spec.lua      (create — 18 tests)
test/botglue/ui_spec.lua              (create — 8 tests)
```

## Constraints

- All tests run in headless plenary (no UI required)
- Module reload in `before_each` consistent with existing conventions
- No external dependencies beyond plenary.nvim
