# v0.2.0 Bugfix Design: Result Parsing + Parallel Requests

**Date:** 2026-02-07
**Status:** Draft
**Scope:** Two critical bugs blocking v0.2.0 from working at all

---

## Bug 1: Result from Claude never inserts into buffer

### Symptoms

Claude Code CLI starts, runs, exits with code 0. `_extract_result()` returns `nil`. User sees "Empty response from Claude". Placeholders disappear, no text replacement. 0/10 runs produce a result.

### Root cause

The stream-json parser in `_extract_result()` and the `on_stdout` callback in `operations.lua` assume a JSON event format that doesn't match the actual Claude Code CLI output.

**Real format** (from `claude -p "..." --output-format stream-json --verbose`):

```json
{"type":"system","subtype":"hook_started",...}
{"type":"system","subtype":"hook_response",...}
{"type":"system","subtype":"init",...}
{"type":"assistant","message":{"content":[{"type":"text","text":"Hi!"}],...}}
{"type":"assistant","message":{"content":[{"type":"tool_use","name":"Read","input":{...}}],...}}
{"type":"user","message":{"content":[{"tool_use_id":"...","type":"tool_result",...}],...}}
{"type":"result","subtype":"success","result":"final text here",...}
```

**Current code expects** (wrong):

| What | Code expects | Reality |
|------|-------------|---------|
| Text streaming | `parsed.type == "stream_event"` + `parsed.event.delta.type == "text_delta"` + `parsed.event.delta.text` | `parsed.type == "assistant"` + `parsed.message.content[].type == "text"` + `.text` |
| Tool use status | `parsed.type == "stream_event"` + `parsed.event.delta.type == "tool_use"` + `delta.name` | `parsed.type == "assistant"` + `parsed.message.content[].type == "tool_use"` + `.name` |
| Final result | `parsed.result` (string) | `parsed.type == "result"` + `parsed.result` (string) — this path actually works |

The `parsed.result` check on line 143 *should* catch the final result line since `{"type":"result","result":"..."}` has a top-level `result` field. However, the `stream_event` / `text_delta` fallback path never fires, so if the `result` line is missed for any reason (buffering edge case, empty result string), there's no fallback.

### Fix

#### `claude.lua:_extract_result(chunks)`

```lua
function M._extract_result(chunks)
  local result_parts = {}

  for _, chunk in ipairs(chunks) do
    local ok, parsed = pcall(vim.json.decode, chunk)
    if ok and parsed then
      -- Primary: final result summary line
      if parsed.type == "result" and parsed.result then
        return parsed.result
      end
      -- Fallback: accumulate text from assistant messages
      if parsed.type == "assistant" and parsed.message and parsed.message.content then
        for _, block in ipairs(parsed.message.content) do
          if block.type == "text" and block.text then
            table.insert(result_parts, block.text)
          end
        end
      end
    end
  end

  if #result_parts > 0 then
    return table.concat(result_parts, "")
  end

  return nil
end
```

#### `operations.lua:on_stdout`

```lua
on_stdout = function(parsed)
  if parsed.type == "assistant" and parsed.message and parsed.message.content then
    for _, block in ipairs(parsed.message.content) do
      if block.type == "tool_use" and block.name then
        top_status:push("Using " .. block.name .. "...")
      end
    end
  end
end,
```

---

## Bug 2: Cannot run multiple requests in parallel

### Symptoms

Second request shows "Another request is already running" error.

### Root cause

Module-level singletons in `claude.lua`:

```lua
M._active_job = nil       -- one slot
M._timeout_timer = nil    -- one timer
M._cancel_reason = nil    -- one reason
```

Guard at line 59-62 blocks any concurrent request.

`operations.lua` stores a single `M._cleanup` function.

### Fix: Request handle pattern

`claude.start()` returns a per-request handle. No module-level state.

### Also: Remove cancel functionality

Per user decision, cancel is being removed entirely from v0.2.0.

---

## Changes by file

### `lua/botglue/claude.lua`

1. **Delete module-level state:** `M._active_job`, `M._timeout_timer`, `M._cancel_reason`
2. **Delete the guard** "Another request is already running" (lines 59-62)
3. **`start()` returns a handle:**
   ```lua
   function M.start(prompt, ctx, observer)
     local handle = {}
     local stdout_chunks = {}
     local partial = ""

     handle.job_id = vim.fn.jobstart(cmd, { ... })

     -- Start per-request timeout
     handle.timeout_timer = vim.uv.new_timer()
     handle.timeout_timer:start(timeout_ms, 0, vim.schedule_wrap(function()
       if handle.job_id then
         vim.fn.jobstop(handle.job_id)
         handle.job_id = nil
       end
       -- clear timer
     end))

     return handle
   end
   ```
4. **Delete `M.cancel()`**
5. **Delete `M._start_timeout()` / `M._clear_timeout()`** — timeout logic moves inline into `start()`
6. **Fix `_extract_result()`** as described above

### `lua/botglue/operations.lua`

1. **Delete `M._cleanup`** module-level variable
2. **Delete `M.cancel()`** function
3. **`run()`:** `claude.start()` returns handle, cleanup is local per-request, no module state
4. **Fix `on_stdout`** callback to match real CLI format

### `lua/botglue/init.lua`

1. **Delete `M.cancel()`** function
2. **Delete `<leader>ps` keymap** registration (cancel keymap)
3. **Remove `:BotglueCancel` command** if it exists (check if registered somewhere)

### Tests

#### `test/botglue/claude_spec.lua`

1. **Update `_extract_result` tests** with real CLI JSON format:
   - Test: returns result from `{"type":"result","result":"text"}`
   - Test: accumulates text from `{"type":"assistant","message":{"content":[{"type":"text","text":"..."}]}}`
   - Test: prefers `type=="result"` over accumulated assistant text
   - Test: handles multi-turn with tool_use + text blocks in same message
   - Test: ignores system/user events
   - Test: returns nil for empty chunks
2. **Delete cancel tests**

#### `test/botglue/operations_spec.lua`

1. **Delete all cancel-related tests** (3 tests)
2. **Update `run` tests** — mock `claude.start` to return a handle instead of void
3. **Add test: two parallel requests** — both call `claude.start`, both complete independently, both replace their selections

---

## Implementation order

1. Fix `_extract_result()` and `on_stdout` parsing (Bug 1)
2. Remove cancel from all three files + tests
3. Refactor `claude.start()` to return handle, remove module-level state (Bug 2)
4. Update `operations.run()` for handle pattern
5. Update all tests
6. Run `make pr-ready`
