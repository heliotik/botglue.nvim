# v0.2.0 Test Coverage Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add 26 tests for `operations.lua` and `ui.lua`, bringing total from 34 to 60.

**Architecture:** TDD with module mocking via `package.loaded`. Extract two pure helpers from `ui.lua` for testability. All tests run in headless plenary with no UI dependencies.

**Tech Stack:** Lua, plenary.nvim (busted), Neovim API (`nvim_create_buf`, `nvim_buf_set_mark`, `nvim_buf_set_text`)

---

### Task 1: Extract `_next_model` helper from ui.lua

**Files:**
- Modify: `lua/botglue/ui.lua`
- Test: `test/botglue/ui_spec.lua`

**Step 1: Create test file with first failing test**

Create `test/botglue/ui_spec.lua`:

```lua
describe("botglue.ui", function()
  local ui

  before_each(function()
    package.loaded["botglue.ui"] = nil
    package.loaded["botglue.config"] = nil
    local config = require("botglue.config")
    config.setup()
    ui = require("botglue.ui")
  end)

  describe("_next_model", function()
    it("cycles opus to sonnet", function()
      assert.equals("sonnet", ui._next_model("opus", { "opus", "sonnet", "haiku" }))
    end)
  end)
end)
```

**Step 2: Run test to verify it fails**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: FAIL — `_next_model` is nil

**Step 3: Add `_next_model` to ui.lua**

Add before `capture_input` function (around line 5 of `lua/botglue/ui.lua`):

```lua
--- Cycle to next model in list. Pure function for testability.
--- @param current string current model name
--- @param models string[] ordered list of model names
--- @return string next model
function M._next_model(current, models)
  local idx = 1
  for i, m in ipairs(models) do
    if m == current then
      idx = i
      break
    end
  end
  return models[(idx % #models) + 1]
end
```

Then update `cycle_model` closure inside `capture_input` (around line 79) to use it:

Replace:
```lua
  local function cycle_model()
    local idx = 1
    for i, m in ipairs(models) do
      if m == current_model then
        idx = i
        break
      end
    end
    idx = (idx % #models) + 1
    current_model = models[idx]
```

With:
```lua
  local function cycle_model()
    current_model = M._next_model(current_model, models)
```

**Step 4: Run test to verify it passes**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: PASS

**Step 5: Add remaining `_next_model` tests**

Append to the `_next_model` describe block in `test/botglue/ui_spec.lua`:

```lua
    it("cycles haiku to opus (wraps around)", function()
      assert.equals("opus", ui._next_model("haiku", { "opus", "sonnet", "haiku" }))
    end)

    it("returns same model for single-element list", function()
      assert.equals("opus", ui._next_model("opus", { "opus" }))
    end)

    it("defaults to second element when model not in list", function()
      assert.equals("sonnet", ui._next_model("unknown", { "opus", "sonnet", "haiku" }))
    end)
```

**Step 6: Run tests to verify all pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: 4 pass, 0 fail

**Step 7: Commit**

```bash
git add lua/botglue/ui.lua test/botglue/ui_spec.lua
git commit -m "feat(ui): extract _next_model helper with tests"
```

---

### Task 2: Extract `_resolve_input` helper from ui.lua

**Files:**
- Modify: `lua/botglue/ui.lua`
- Modify: `test/botglue/ui_spec.lua`

**Step 1: Add first failing test**

Append to `test/botglue/ui_spec.lua` inside the main `describe` block:

```lua
  describe("_resolve_input", function()
    it("calls on_submit with trimmed text and model", function()
      local submitted_prompt, submitted_model
      ui._resolve_input("  hello world  ", function(p, m)
        submitted_prompt = p
        submitted_model = m
      end, nil, "opus")
      assert.equals("hello world", submitted_prompt)
      assert.equals("opus", submitted_model)
    end)
  end)
```

**Step 2: Run test to verify it fails**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: FAIL — `_resolve_input` is nil

**Step 3: Add `_resolve_input` to ui.lua**

Add after `_next_model` function in `lua/botglue/ui.lua`:

```lua
--- Resolve input text into submit or cancel action. Pure function for testability.
--- @param text string raw input text (may be multi-line)
--- @param on_submit fun(prompt: string, model: string)
--- @param on_cancel fun()|nil
--- @param model string current model
function M._resolve_input(text, on_submit, on_cancel, model)
  local input = vim.trim(text)
  if input ~= "" then
    on_submit(input, model)
  elseif on_cancel then
    on_cancel()
  end
end
```

Then update `submit` closure inside `capture_input` to use it. Replace:

```lua
  local function submit()
    local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
    local input = vim.trim(table.concat(lines, "\n"))
    close_window()
    if input ~= "" then
      on_submit(input, current_model)
    elseif on_cancel then
      on_cancel()
    end
  end
```

With:

```lua
  local function submit()
    local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
    local text = table.concat(lines, "\n")
    close_window()
    M._resolve_input(text, on_submit, on_cancel, current_model)
  end
```

**Step 4: Run test to verify it passes**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: 5 pass, 0 fail

**Step 5: Add remaining `_resolve_input` tests**

Append inside the `_resolve_input` describe block:

```lua
    it("calls on_cancel for whitespace-only input", function()
      local cancelled = false
      ui._resolve_input("  \n  ", function() end, function()
        cancelled = true
      end, "opus")
      assert.is_true(cancelled)
    end)

    it("does not crash when on_cancel is nil and input is empty", function()
      assert.has_no.errors(function()
        ui._resolve_input("", function() end, nil, "opus")
      end)
    end)

    it("preserves newlines in non-empty multi-line text", function()
      local submitted_prompt
      ui._resolve_input("line1\nline2", function(p)
        submitted_prompt = p
      end, nil, "opus")
      assert.equals("line1\nline2", submitted_prompt)
    end)
```

**Step 6: Run tests to verify all pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/ui_spec.lua"`

Expected: 8 pass, 0 fail

**Step 7: Run format check**

Run: `make fmt`

**Step 8: Commit**

```bash
git add lua/botglue/ui.lua test/botglue/ui_spec.lua
git commit -m "feat(ui): extract _resolve_input helper with tests"
```

---

### Task 3: Test `replace_selection`

**Files:**
- Create: `test/botglue/operations_spec.lua`

**Step 1: Create test file with replace_selection tests**

Create `test/botglue/operations_spec.lua`:

```lua
describe("botglue.operations", function()
  local operations

  before_each(function()
    package.loaded["botglue.operations"] = nil
    package.loaded["botglue.config"] = nil
    package.loaded["botglue.claude"] = nil
    package.loaded["botglue.display"] = nil

    local config = require("botglue.config")
    config.setup()

    operations = require("botglue.operations")
  end)

  describe("replace_selection", function()
    local bufnr

    before_each(function()
      bufnr = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
        "line one",
        "line two",
        "line three",
        "line four",
      })
    end)

    after_each(function()
      pcall(vim.api.nvim_buf_delete, bufnr, { force = true })
    end)

    it("replaces single-line text", function()
      local sel = {
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.replace_selection(sel, "replaced")
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      assert.equals("replaced", lines[2])
      assert.equals(4, #lines)
    end)

    it("replaces with multi-line text", function()
      local sel = {
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.replace_selection(sel, "new line A\nnew line B\nnew line C")
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      assert.equals(6, #lines)
      assert.equals("new line A", lines[2])
      assert.equals("new line B", lines[3])
      assert.equals("new line C", lines[4])
    end)

    it("shrinks buffer when replacing multi-line with single-line", function()
      local sel = {
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 3,
        end_col = 10,
      }
      operations.replace_selection(sel, "merged")
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      assert.equals(3, #lines)
      assert.equals("merged", lines[2])
    end)

    it("does not crash on invalid buffer", function()
      local dead_buf = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_delete(dead_buf, { force = true })
      local sel = {
        bufnr = dead_buf,
        start_line = 1,
        start_col = 0,
        end_line = 1,
        end_col = 5,
      }
      assert.has_no.errors(function()
        operations.replace_selection(sel, "nope")
      end)
    end)
  end)
end)
```

**Step 2: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/operations_spec.lua"`

Expected: 4 pass, 0 fail

**Step 3: Commit**

```bash
git add test/botglue/operations_spec.lua
git commit -m "test(operations): add replace_selection tests"
```

---

### Task 4: Test `get_visual_selection`

**Files:**
- Modify: `test/botglue/operations_spec.lua`

Visual selection marks (`'<` and `'>`) are set per-buffer via `nvim_buf_set_mark`. In headless plenary tests, we set these marks directly to simulate a selection.

**Step 1: Add get_visual_selection describe block**

Add inside the main `describe("botglue.operations")` block, after `replace_selection`:

```lua
  describe("get_visual_selection", function()
    local bufnr

    before_each(function()
      bufnr = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
        "line one",
        "line two",
        "line three",
        "line four",
      })
      -- Make it the current buffer so getpos("'<") works
      vim.api.nvim_set_current_buf(bufnr)
    end)

    after_each(function()
      pcall(vim.api.nvim_buf_delete, bufnr, { force = true })
    end)

    it("returns nil when no marks set", function()
      assert.is_nil(operations.get_visual_selection(bufnr))
    end)

    it("extracts charwise single-line selection", function()
      -- Select "line" from "line two" (cols 1-4, 1-indexed)
      vim.api.nvim_buf_set_mark(bufnr, "<", 2, 0, {})
      vim.api.nvim_buf_set_mark(bufnr, ">", 2, 3, {})
      local sel = operations.get_visual_selection(bufnr)
      assert.is_truthy(sel)
      assert.equals("line", sel.text)
      assert.equals(bufnr, sel.bufnr)
      assert.equals(2, sel.start_line)
      assert.equals(2, sel.end_line)
    end)

    it("extracts charwise multi-line selection", function()
      vim.api.nvim_buf_set_mark(bufnr, "<", 2, 0, {})
      vim.api.nvim_buf_set_mark(bufnr, ">", 3, 9, {})
      local sel = operations.get_visual_selection(bufnr)
      assert.is_truthy(sel)
      assert.equals("line two\nline three", sel.text)
      assert.equals(2, sel.start_line)
      assert.equals(3, sel.end_line)
    end)

    it("handles linewise selection via maxcol", function()
      -- Linewise: col set to v:maxcol (2147483647)
      vim.api.nvim_buf_set_mark(bufnr, "<", 2, 2147483646, {})
      vim.api.nvim_buf_set_mark(bufnr, ">", 3, 2147483646, {})
      local sel = operations.get_visual_selection(bufnr)
      assert.is_truthy(sel)
      assert.equals(0, sel.start_col)
      assert.equals(2, sel.start_line)
      assert.equals(3, sel.end_line)
    end)

    it("uses explicit bufnr parameter", function()
      local other_buf = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_lines(other_buf, 0, -1, false, { "other content" })
      vim.api.nvim_set_current_buf(other_buf)
      -- Marks are on bufnr, not other_buf
      vim.api.nvim_buf_set_mark(bufnr, "<", 1, 0, {})
      vim.api.nvim_buf_set_mark(bufnr, ">", 1, 7, {})
      -- Switch to other_buf, but pass bufnr explicitly
      local sel = operations.get_visual_selection(bufnr)
      assert.is_truthy(sel)
      assert.equals(bufnr, sel.bufnr)
      assert.equals("line one", sel.text)
      pcall(vim.api.nvim_buf_delete, other_buf, { force = true })
    end)
  end)
```

**Step 2: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/operations_spec.lua"`

Expected: 9 pass, 0 fail

**Step 3: Commit**

```bash
git add test/botglue/operations_spec.lua
git commit -m "test(operations): add get_visual_selection tests"
```

---

### Task 5: Test `run()` with mocked claude

**Files:**
- Modify: `test/botglue/operations_spec.lua`

This is the most complex test group. We mock `botglue.claude` and `botglue.display` before requiring `botglue.operations`.

**Step 1: Add run() describe block with mocks**

Add inside the main `describe("botglue.operations")` block:

```lua
  describe("run", function()
    local bufnr
    local mock_claude
    local mock_marks_deleted

    before_each(function()
      -- Reset all modules for clean mock injection
      package.loaded["botglue.operations"] = nil
      package.loaded["botglue.config"] = nil
      package.loaded["botglue.claude"] = nil
      package.loaded["botglue.display"] = nil

      local config = require("botglue.config")
      config.setup()

      -- Mock claude
      mock_claude = {
        start = function(prompt, ctx, observer)
          mock_claude._last_prompt = prompt
          mock_claude._last_ctx = ctx
          mock_claude._last_observer = observer
        end,
        cancel = function()
          mock_claude._cancelled = true
        end,
        _cancelled = false,
      }
      package.loaded["botglue.claude"] = mock_claude

      -- Mock display — minimal stubs that track deletion
      mock_marks_deleted = 0
      local mock_mark = {
        set_virtual_text = function() end,
        delete = function()
          mock_marks_deleted = mock_marks_deleted + 1
        end,
        is_valid = function()
          return true
        end,
      }
      package.loaded["botglue.display"] = {
        Mark = {
          above = function()
            return mock_mark
          end,
          at = function()
            return mock_mark
          end,
        },
        RequestStatus = {
          new = function(_, _, _, _)
            return {
              start = function() end,
              stop = function() end,
              push = function() end,
              get = function()
                return {}
              end,
            }
          end,
        },
      }

      operations = require("botglue.operations")

      bufnr = vim.api.nvim_create_buf(false, true)
      vim.api.nvim_buf_set_lines(bufnr, 0, -1, false, {
        "line one",
        "line two",
        "line three",
      })
    end)

    after_each(function()
      pcall(vim.api.nvim_buf_delete, bufnr, { force = true })
    end)

    it("returns early on nil selection", function()
      operations.run("test prompt", "opus", nil)
      assert.is_nil(mock_claude._last_observer)
    end)

    it("returns early on empty text", function()
      operations.run("test prompt", "opus", { text = "", bufnr = bufnr })
      assert.is_nil(mock_claude._last_observer)
    end)

    it("passes correct context to claude.start", function()
      local sel = {
        text = "line two",
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.run("simplify", "sonnet", sel)
      assert.is_truthy(mock_claude._last_ctx)
      assert.equals(2, mock_claude._last_ctx.start_line)
      assert.equals(2, mock_claude._last_ctx.end_line)
      assert.equals("sonnet", mock_claude._last_ctx.model)
      assert.equals("simplify", mock_claude._last_prompt)
    end)

    it("replaces selection on successful completion", function()
      local sel = {
        text = "line two",
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.run("test", "opus", sel)
      -- Simulate successful completion
      mock_claude._last_observer.on_complete(nil, "replaced text")
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      assert.equals("replaced text", lines[2])
    end)

    it("does not replace selection on error", function()
      local sel = {
        text = "line two",
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.run("test", "opus", sel)
      mock_claude._last_observer.on_complete("timeout", nil)
      local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
      assert.equals("line two", lines[2])
    end)

    it("cleans up marks on completion", function()
      local sel = {
        text = "line two",
        bufnr = bufnr,
        start_line = 2,
        start_col = 0,
        end_line = 2,
        end_col = 8,
      }
      operations.run("test", "opus", sel)
      mock_claude._last_observer.on_complete(nil, "done")
      assert.equals(2, mock_marks_deleted)
    end)
  end)
```

**Step 2: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/operations_spec.lua"`

Expected: 15 pass, 0 fail

**Step 3: Commit**

```bash
git add test/botglue/operations_spec.lua
git commit -m "test(operations): add run() tests with mocked claude"
```

---

### Task 6: Test `cancel()`

**Files:**
- Modify: `test/botglue/operations_spec.lua`

**Step 1: Add cancel() describe block**

Add inside the main `describe("botglue.operations")` block. This reuses the mocked `operations` from the `run()` setup, so place it inside the same `describe("run")` parent, or create a new one with the same mock setup. Simplest: add a new top-level describe that shares the mock pattern.

Add at the end of the main describe block:

```lua
  describe("cancel", function()
    local mock_claude

    before_each(function()
      package.loaded["botglue.operations"] = nil
      package.loaded["botglue.config"] = nil
      package.loaded["botglue.claude"] = nil
      package.loaded["botglue.display"] = nil

      local config = require("botglue.config")
      config.setup()

      mock_claude = {
        start = function() end,
        cancel = function()
          mock_claude._cancelled = true
        end,
        _cancelled = false,
      }
      package.loaded["botglue.claude"] = mock_claude

      package.loaded["botglue.display"] = {
        Mark = {
          above = function()
            return { set_virtual_text = function() end, delete = function() end }
          end,
          at = function()
            return { set_virtual_text = function() end, delete = function() end }
          end,
        },
        RequestStatus = {
          new = function()
            return { start = function() end, stop = function() end, push = function() end }
          end,
        },
      }

      operations = require("botglue.operations")
    end)

    it("calls claude.cancel", function()
      operations.cancel()
      assert.is_true(mock_claude._cancelled)
    end)

    it("runs cleanup function when set", function()
      local cleaned = false
      operations._cleanup = function()
        cleaned = true
      end
      operations.cancel()
      assert.is_true(cleaned)
      assert.is_nil(operations._cleanup)
    end)

    it("does not crash when no cleanup set", function()
      operations._cleanup = nil
      assert.has_no.errors(function()
        operations.cancel()
      end)
    end)
  end)
```

**Step 2: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/operations_spec.lua"`

Expected: 18 pass, 0 fail

**Step 3: Commit**

```bash
git add test/botglue/operations_spec.lua
git commit -m "test(operations): add cancel() tests"
```

---

### Task 7: Run full suite and format

**Files:**
- All test and source files

**Step 1: Run full test suite**

Run: `make test`

Expected: 60 pass, 0 fail (config: 9, claude: 11, display: 8, history: 6, operations: 18, ui: 8)

**Step 2: Run formatter**

Run: `make fmt`

**Step 3: Run format check**

Run: `make fmt-check`

Expected: clean

**Step 4: Commit if formatting changed anything**

```bash
git add -A
git commit -m "style: format new test files with stylua"
```

(Only if there were formatting changes.)
