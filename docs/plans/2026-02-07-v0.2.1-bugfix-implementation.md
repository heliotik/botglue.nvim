# v0.2.1 UI Bug Fixes Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 5 UI bugs in the three-panel picker: line formatting, fuzzy highlights, divider focus, autocomplete, cursorline coverage.

**Architecture:** Extract two testable helpers (`_format_list_line`, `_char_to_byte_positions`) from `render_list()`, rewrite `apply_filter()` to match against display strings, replace static divider highlights with dynamic `update_divider_highlight()`, fix autocomplete buffer vars.

**Tech Stack:** Lua, Neovim API, plenary.nvim tests

**Design doc:** `docs/plans/2026-02-07-v0.2.1-bugfix-design.md`

---

## Dependency Graph

```
Task 1 (helper: _format_list_line)
  → Task 2 (helper: _char_to_byte_positions)
    → Task 3 (rewrite render_list + apply_filter)
      → Task 7 (remove dead code)

Task 4 (divider highlights)          ← independent
Task 5 (autocomplete suppression)    ← independent

Task 6 (make pr-ready)               ← after Tasks 1-5
Task 8 (update CLAUDE.md)            ← after Tasks 1-5
Task 9 (code review)                 ← after Task 6+8
Task 10 (retrospective)              ← after Task 9
```

**Parallel groups for subagent-driven-development:**
- **Group A (sequential):** Tasks 1 → 2 → 3 → 7
- **Group B (parallel with A):** Task 4
- **Group C (parallel with A):** Task 5
- **After A+B+C:** Task 6 → Task 8 → Task 9 → Task 10

---

### Task 1: Extract `_format_list_line` helper with tests

**Files:**
- Modify: `lua/botglue/picker.lua` — add new function after `_truncate_prompt` (line 40)
- Modify: `test/botglue/picker_spec.lua` — add new describe block

This helper encapsulates the line formatting logic from Bug 4+5: symmetric padding, inline model tag, full-width padding for cursorline.

**Step 1: Write failing tests**

Add to `test/botglue/picker_spec.lua` after the `_truncate_prompt` describe block (line 80):

```lua
describe("_format_list_line", function()
  it("formats ASCII prompt with model tag and padding", function()
    -- inner_width=40, prompt="hello", model="opus"
    -- Expected: " hello                          [opus] "
    -- left_pad(1) + "hello"(5) + gap(24) + "[opus]"(6) + right_pad(1) + trail(3) = 40
    local line = picker._format_list_line("hello", "opus", 40)
    assert.equals(40, vim.fn.strdisplaywidth(line))
    assert.truthy(vim.startswith(line, " hello"))
    assert.truthy(line:match("%[opus%]"))
    -- Ends with " " (right padding)
    assert.equals(" ", line:sub(-1))
  end)

  it("truncates long prompt to fit", function()
    local long_prompt = string.rep("a", 100)
    local line = picker._format_list_line(long_prompt, "sonnet", 40)
    assert.equals(40, vim.fn.strdisplaywidth(line))
    assert.truthy(line:match("…"))
    assert.truthy(line:match("%[sonnet%]"))
  end)

  it("handles UTF-8 Cyrillic prompt", function()
    local line = picker._format_list_line("переведи на английский", "opus", 50)
    assert.equals(50, vim.fn.strdisplaywidth(line))
    assert.truthy(line:match("%[opus%]"))
  end)

  it("replaces newlines with spaces", function()
    local line = picker._format_list_line("line1\nline2", "haiku", 40)
    assert.equals(40, vim.fn.strdisplaywidth(line))
    assert.is_nil(line:match("\n"))
    assert.truthy(line:match("line1 line2"))
  end)

  it("returns (no matches) line when prompt is nil", function()
    local line = picker._format_list_line(nil, nil, 40)
    assert.equals(40, vim.fn.strdisplaywidth(line))
    assert.truthy(line:match("no matches"))
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: FAIL — `_format_list_line` is not defined

**Step 3: Implement the helper**

Add to `lua/botglue/picker.lua` after `_truncate_prompt` (after line 40, before `local ACTIVE_HL`):

```lua
--- Format a single list line with inline model tag, padded to full width.
--- Returns nil-prompt as a "(no matches)" placeholder line.
--- @param prompt string|nil raw prompt text (may contain newlines)
--- @param model string|nil model name
--- @param inner_width number target display width
--- @return string formatted line of exactly inner_width display columns
function M._format_list_line(prompt, model, inner_width)
  if not prompt then
    local placeholder = " (no matches)"
    local pad = inner_width - vim.fn.strdisplaywidth(placeholder)
    return placeholder .. string.rep(" ", math.max(pad, 0))
  end
  local left_pad = 1
  local right_pad = 1
  local tag = "[" .. model .. "]"
  local tag_w = #tag -- ASCII only, #tag == display width
  local available = inner_width - left_pad - right_pad - tag_w
  local display = prompt:gsub("\n", " ")
  local prompt_text = M._truncate_prompt(display, available)
  local text_w = vim.fn.strdisplaywidth(prompt_text)
  local gap = inner_width - left_pad - text_w - tag_w - right_pad
  return " " .. prompt_text .. string.rep(" ", math.max(gap, 1)) .. tag .. " "
end
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: All PASS

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua test/botglue/picker_spec.lua
git commit -m "feat(picker): add _format_list_line helper with inline model tags"
```

---

### Task 2: Extract `_char_to_byte_positions` helper with tests

**Files:**
- Modify: `lua/botglue/picker.lua` — add new function after `_format_list_line`
- Modify: `test/botglue/picker_spec.lua` — add new describe block

**Depends on:** Task 1 (line format determines `left_pad = 1`)

This helper converts `matchfuzzypos` character positions to byte ranges for `nvim_buf_add_highlight`. Extracted from the highlight loop in `render_list()`.

**Step 1: Write failing tests**

Add to `test/botglue/picker_spec.lua`:

```lua
describe("_char_to_byte_positions", function()
  it("converts ASCII positions with left_pad offset", function()
    -- line = " hello world" (1 space left pad)
    -- char_positions from matchfuzzypos on "hello world": {0, 6} → 'h', 'w'
    -- In padded line: char 0+1=1 ('h'), char 6+1=7 ('w')
    -- ASCII: byte == char, so byte ranges: {2, 3}, {8, 9} (0-indexed bytes)
    local result = picker._char_to_byte_positions(" hello world", { 0, 6 }, 1)
    assert.same({ { 1, 2 }, { 7, 8 } }, result)
  end)

  it("converts Cyrillic (2-byte) positions correctly", function()
    -- "привет" = 6 chars, 12 bytes (each Cyrillic char = 2 bytes)
    -- line = " привет" (1 space left pad)
    -- char_positions: {0, 3} → 'п'(pos 0), 'в'(pos 3)
    -- In padded line: char 0+1=1, char 3+1=4
    -- byteidx(" привет", 1) = 1, byteidx(" привет", 2) = 3
    -- byteidx(" привет", 4) = 7, byteidx(" привет", 5) = 9
    local result = picker._char_to_byte_positions(" привет", { 0, 3 }, 1)
    assert.same({ { 1, 3 }, { 7, 9 } }, result)
  end)

  it("skips out-of-bounds positions", function()
    local result = picker._char_to_byte_positions(" hi", { 0, 99 }, 1)
    assert.same({ { 1, 2 } }, result)
  end)

  it("returns empty list for empty positions", function()
    local result = picker._char_to_byte_positions(" hello", {}, 1)
    assert.same({}, result)
  end)
end)
```

**Step 2: Run tests to verify they fail**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: FAIL — `_char_to_byte_positions` is not defined

**Step 3: Implement the helper**

Add to `lua/botglue/picker.lua` after `_format_list_line`:

```lua
--- Convert matchfuzzypos character positions to byte ranges for nvim_buf_add_highlight.
--- @param line_text string the full padded line in the buffer
--- @param char_positions number[] 0-indexed character positions from matchfuzzypos
--- @param left_pad number number of padding characters before the prompt text
--- @return table[] list of {byte_start, byte_end} pairs (0-indexed)
function M._char_to_byte_positions(line_text, char_positions, left_pad)
  local result = {}
  for _, char_pos in ipairs(char_positions) do
    local line_char_pos = char_pos + left_pad
    local byte_start = vim.fn.byteidx(line_text, line_char_pos)
    local byte_end = vim.fn.byteidx(line_text, line_char_pos + 1)
    if byte_start >= 0 and byte_end >= 0 then
      table.insert(result, { byte_start, byte_end })
    end
  end
  return result
end
```

**Step 4: Run tests to verify they pass**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: All PASS

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua test/botglue/picker_spec.lua
git commit -m "feat(picker): add _char_to_byte_positions helper for UTF-8 fuzzy highlights"
```

---

### Task 3: Rewrite `render_list()` and `apply_filter()` using new helpers

**Files:**
- Modify: `lua/botglue/picker.lua` — `render_list()` (lines 345-390), `apply_filter()` (lines 419-446)

**Depends on:** Tasks 1+2 (helpers must exist)

**Step 1: Rewrite `render_list()`**

Replace the current `render_list()` function body (lines 345-390) with:

```lua
local function render_list()
  local lines = {}
  if #filtered_entries == 0 then
    lines = { M._format_list_line(nil, nil, inner_width) }
  else
    for _, entry in ipairs(filtered_entries) do
      table.insert(lines, M._format_list_line(entry.prompt, entry.model, inner_width))
    end
  end
  vim.bo[list_buf].modifiable = true
  vim.api.nvim_buf_set_lines(list_buf, 0, -1, false, lines)
  -- Highlight fuzzy match positions
  vim.api.nvim_buf_clear_namespace(list_buf, filter_hl_ns, 0, -1)
  for i, entry in ipairs(filtered_entries) do
    local display = entry.prompt:gsub("\n", " ")
    local positions = match_positions[display]
    if positions then
      local byte_ranges = M._char_to_byte_positions(lines[i], positions, 1)
      for _, range in ipairs(byte_ranges) do
        pcall(
          vim.api.nvim_buf_add_highlight,
          list_buf,
          filter_hl_ns,
          "Search",
          i - 1,
          range[1],
          range[2]
        )
      end
    end
  end
  vim.bo[list_buf].modifiable = false
  selected_idx = math.max(1, math.min(selected_idx, #filtered_entries))
  if vim.api.nvim_win_is_valid(list_win) and #filtered_entries > 0 then
    vim.api.nvim_win_set_cursor(list_win, { selected_idx, 0 })
  end
end
```

**Key changes vs current code:**
- Uses `_format_list_line` instead of inline padding logic
- Removes `list_ns` extmark calls (model tags are now inline)
- Uses `_char_to_byte_positions` for correct UTF-8 highlight ranges
- `match_positions` keyed by display string (after `gsub("\n", " ")`)

**Step 2: Rewrite `apply_filter()`**

Replace the current `apply_filter()` body (lines 419-446) with:

```lua
local function apply_filter()
  local text = vim.trim(vim.api.nvim_buf_get_lines(filter_buf, 0, 1, false)[1] or "")
  match_positions = {}
  if text == "" then
    filtered_entries = all_entries
  else
    local display_strings = {}
    local display_to_entries = {}
    for _, e in ipairs(all_entries) do
      local d = e.prompt:gsub("\n", " ")
      table.insert(display_strings, d)
      display_to_entries[d] = e
    end
    local result = vim.fn.matchfuzzypos(display_strings, text)
    local matched = result[1]
    local positions = result[2]
    local matched_set = {}
    for i, m in ipairs(matched) do
      match_positions[m] = positions[i]
      matched_set[m] = true
    end
    filtered_entries = {}
    for _, e in ipairs(all_entries) do
      local d = e.prompt:gsub("\n", " ")
      if matched_set[d] then
        table.insert(filtered_entries, e)
      end
    end
  end
  selected_idx = 1
  render_list()
  update_preview()
  update_filter_placeholder()
end
```

**Key change:** `matchfuzzypos` runs against display-ready strings (after newline replacement), not raw `entry.prompt`. Positions are stored keyed by display string.

**Step 3: Remove `list_ns` from state**

Delete line 225: `local list_ns = vim.api.nvim_create_namespace("botglue_list")`

This namespace was used only for model tag extmarks, which are now inline text.

**Step 4: Run all tests**

Run: `make test`
Expected: All 71+ tests PASS (no existing test depended on extmark model tags)

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "fix(picker): rewrite render_list/apply_filter for correct UTF-8 highlights and inline model tags"
```

---

### Task 4: Dynamic divider highlights for active panel indication

**Files:**
- Modify: `lua/botglue/picker.lua` — container setup (line 285), divider highlights (lines 262-264), focus functions (lines 450-469), `_open_prompt_only` (line 98)

**Depends on:** Nothing (independent of Tasks 1-3)

**Testing:** Manual only — float windows cannot be created in headless mode.

**Step 1: Remove yellow container border in `_open_full`**

Delete line 285:
```lua
vim.api.nvim_set_option_value("winhl", "FloatBorder:" .. ACTIVE_HL, { win = container_win })
```

**Step 2: Remove yellow container border in `_open_prompt_only`**

Delete line 98:
```lua
vim.api.nvim_set_option_value("winhl", "FloatBorder:" .. ACTIVE_HL, { win = container_win })
```

**Step 3: Replace static divider highlights with `update_divider_highlight` function**

Replace lines 261-264 (static highlights):
```lua
-- Highlight divider lines
local divider_ns = vim.api.nvim_create_namespace("botglue_divider")
vim.api.nvim_buf_add_highlight(container_buf, divider_ns, "FloatBorder", 1, 0, -1)
vim.api.nvim_buf_add_highlight(container_buf, divider_ns, "FloatBorder", 2 + list_height, 0, -1)
```

With dynamic function:
```lua
local divider_ns = vim.api.nvim_create_namespace("botglue_divider")
local divider_rows = {
  list = 1,
  prompt = 2 + list_height,
}

local function update_divider_highlight(active_panel)
  vim.api.nvim_buf_clear_namespace(container_buf, divider_ns, 0, -1)
  for panel, row in pairs(divider_rows) do
    local hl = (panel == active_panel) and ACTIVE_HL or "FloatBorder"
    vim.api.nvim_buf_add_highlight(container_buf, divider_ns, hl, row, 0, -1)
  end
end
```

**Step 4: Add `update_divider_highlight` calls to focus functions**

Update `focus_list()` (~line 450):
```lua
local function focus_list()
  if vim.api.nvim_win_is_valid(list_win) then
    vim.api.nvim_set_current_win(list_win)
    update_divider_highlight("list")
  end
end
```

Update `focus_filter()` (~line 456):
```lua
local function focus_filter()
  if vim.api.nvim_win_is_valid(filter_win) then
    vim.api.nvim_set_current_win(filter_win)
    vim.cmd("startinsert!")
    update_divider_highlight(nil)
  end
end
```

Update `focus_prompt()` (~line 463):
```lua
local function focus_prompt(selected_text)
  if selected_text then
    draft.text = selected_text
  end
  prompt_handle.set_draft(draft.text)
  prompt_handle.focus()
  update_divider_highlight("prompt")
end
```

**Step 5: Set initial divider state**

The initial `focus_list()` call at line 669 now triggers `update_divider_highlight("list")` automatically. No separate call needed.

**Step 6: Run all tests**

Run: `make test`
Expected: All tests PASS (no test depends on float window highlights)

**Step 7: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "fix(picker): highlight active panel divider instead of entire container border"
```

---

### Task 5: Fix autocomplete suppression for nvim-cmp and blink.cmp

**Files:**
- Modify: `lua/botglue/picker.lua` — lines 298, 318 (filter_buf, list_buf)
- Modify: `lua/botglue/ui.lua` — line 88 (prompt buf)

**Depends on:** Nothing (independent)

**Testing:** Manual only — requires actual completion plugin loaded.

**Step 1: Update `picker.lua` filter_buf vars**

Replace line 298:
```lua
vim.b[filter_buf].cmp = false
```
With:
```lua
vim.b[filter_buf].cmp_enabled = false
vim.b[filter_buf].completion = false
```

**Step 2: Update `picker.lua` list_buf vars**

Replace line 318:
```lua
vim.b[list_buf].cmp = false
```
With:
```lua
vim.b[list_buf].cmp_enabled = false
vim.b[list_buf].completion = false
```

**Step 3: Update `ui.lua` prompt buf vars**

Replace line 88:
```lua
vim.b[buf].cmp = false
```
With:
```lua
vim.b[buf].cmp_enabled = false
vim.b[buf].completion = false
```

**Step 4: Run all tests**

Run: `make test`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua lua/botglue/ui.lua
git commit -m "fix(picker,ui): use cmp_enabled/completion buffer vars for autocomplete suppression"
```

---

### Task 6: Run `make pr-ready` — full validation

**Depends on:** Tasks 1-5 (all code changes complete)

**Step 1: Run `make pr-ready`**

Run: `make pr-ready`
Expected: lint PASS, test PASS, format check PASS

**Step 2: If format fails, run `make fmt` and commit**

Run: `make fmt && make pr-ready`

```bash
git add -u
git commit -m "style: format with stylua"
```

---

### Task 7: Remove dead code

**Files:**
- Modify: `lua/botglue/picker.lua` — remove unused `list_ns` references

**Depends on:** Task 3 (render_list rewrite removed all `list_ns` usage)

**Step 1: Verify `list_ns` is unused**

Search for `list_ns` in `picker.lua`. After Task 3, the only reference should be the declaration (line 225). If Task 3 already removed it, this task is a no-op.

**Step 2: Remove if still present**

Delete the line: `local list_ns = vim.api.nvim_create_namespace("botglue_list")`

**Step 3: Run tests**

Run: `make test`
Expected: All PASS

**Step 4: Commit (if changes made)**

```bash
git add lua/botglue/picker.lua
git commit -m "chore(picker): remove unused list_ns namespace"
```

---

### Task 8: Update CLAUDE.md

**Files:**
- Modify: `CLAUDE.md`

**Depends on:** Tasks 1-5 (need final state of code)

**Step 1: Update UI Architecture section**

Replace line 39:
```
- **Panel 2:** History list — sorted by frequency, model tags as right-aligned extmarks (`Comment` hl)
```
With:
```
- **Panel 2:** History list — sorted by frequency, model tags inline with space-padding to full width
```

Add after line 42 (after "Container uses `zindex = 40`..."):
```
Active panel indicated by yellow (`BotglueActiveBorder`) highlight on its divider label; container border uses default `FloatBorder`.
```

**Step 2: Update Gotchas section**

Replace line 111:
```
- `matchfuzzypos` returns 0-indexed byte positions — offset by 2 for `"  "` left padding when highlighting list lines
```
With:
```
- `matchfuzzypos` returns 0-indexed **character** positions — use `vim.fn.byteidx()` to convert to byte offsets for `nvim_buf_add_highlight`; see `_char_to_byte_positions` helper
- Autocomplete suppression: set `vim.b[buf].cmp_enabled = false` (nvim-cmp) and `vim.b[buf].completion = false` (blink.cmp) — `vim.b[buf].cmp = false` alone is insufficient
```

**Step 3: Update test counts in Testing table**

Update `picker_spec.lua` row — count will increase by ~9 tests (5 for `_format_list_line`, 4 for `_char_to_byte_positions`). Update total accordingly.

Current: `| picker_spec.lua | 10 |` and `71 tests`
New: `| picker_spec.lua | 19 |` and `80 tests` (approximate — verify after Task 6)

**Step 4: Commit**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md for v0.2.1 bugfix changes"
```

---

### Task 9: Code review

**Depends on:** Tasks 6+8

Use `superpowers:requesting-code-review` to review all changes since the last tagged commit.

**Step 1: Generate diff for review**

Run: `git log --oneline` to identify the commit range, then `git diff <base>..HEAD`

**Step 2: Review criteria**

- All 5 bugs addressed per design doc
- No regressions (make pr-ready passes)
- Helpers are pure functions with correct types
- UTF-8 handling uses `byteidx`/`strdisplaywidth`, never raw `#string` for display
- No dead code left behind
- CLAUDE.md reflects current state

**Step 3: Fix any issues found, re-run `make pr-ready`**

```bash
git add -u
git commit -m "fix: address code review findings"
```

---

### Task 10: Retrospective

**Depends on:** Task 9

Analyze the implementation process and record improvement suggestions.

**Hooks:**
- Would a pre-commit hook running `make fmt` prevent format-only commits?
- Would a pre-push hook running `make pr-ready` catch issues earlier?

**Skills:**
- Neovim extmark API patterns (namespace lifecycle, highlight application, virt_text options)
- `matchfuzzypos` → `byteidx` conversion pattern — reusable for any fuzzy picker
- Float window layout math (container + inner panels, zindex, border offsets)

**Agents:**
- Tasks 3-5 could have been parallelized (3 depends on 1+2, but 4+5 are independent)
- Consider a "Neovim UI tester" agent that validates float window behavior in a running Neovim instance

Record findings as comments in the final commit or conversation notes.

---

## Summary Table

| Task | Description | Files | Depends On | Tests | Parallel Group |
|------|-------------|-------|------------|-------|----------------|
| 1 | `_format_list_line` helper | picker.lua, picker_spec.lua | — | 5 new | A |
| 2 | `_char_to_byte_positions` helper | picker.lua, picker_spec.lua | 1 | 4 new | A |
| 3 | Rewrite render_list + apply_filter | picker.lua | 1, 2 | existing pass | A |
| 4 | Dynamic divider highlights | picker.lua | — | manual | B |
| 5 | Autocomplete suppression | picker.lua, ui.lua | — | manual | C |
| 6 | make pr-ready | — | 1-5 | all green | — |
| 7 | Remove dead code | picker.lua | 3 | existing pass | A |
| 8 | Update CLAUDE.md | CLAUDE.md | 1-5 | — | — |
| 9 | Code review | — | 6, 8 | — | — |
| 10 | Retrospective | — | 9 | — | — |
