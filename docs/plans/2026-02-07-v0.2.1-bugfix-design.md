# Design: 5 UI Bug Fixes for botglue.nvim v0.2.1

## Overview

Five bug fixes for the three-panel picker UI. All changes confined to `picker.lua`. No changes to `ui.lua`, `config.lua`, `history.lua`, `display.lua`, `operations.lua`, `claude.lua`, or `init.lua`.

## Implementation Order

| Step | Bug | Depends On |
|------|-----|------------|
| 1 | Bug 4+5: List line formatting (padding + inline model tag) | — |
| 2 | Bug 2: Fuzzy highlight positions | Step 1 (line format) |
| 3 | Bug 1: Active panel divider highlights | — |
| 4 | Bug 3: Autocomplete suppression | — |

Steps 1-2 are sequential (highlight positions depend on line format). Steps 3 and 4 are independent of everything and can be done in parallel with each other.

## Bug 4+5: List Line Formatting

### Problem

Two related issues in `render_list()`:
- **Bug 4:** 2-space left padding, no right padding — asymmetric look
- **Bug 5:** `cursorline` doesn't extend to `right_align` virt_text — known Neovim limitation (confirmed via issue tracker)

### Solution

Replace right-aligned extmarks with inline model tags. Pad each line to full `inner_width` so `cursorline` covers the entire row.

Line format: `" {prompt_text}{spaces}[{model}] "` — 1 space left padding, 1 space right padding, model tag right-justified via space padding.

In `render_list()`:

```lua
local left_pad = 1
local right_pad = 1
local tag_max = 8  -- "[sonnet]" is longest at 8 chars
local available = inner_width - left_pad - right_pad - tag_max
for _, entry in ipairs(filtered_entries) do
  local display = entry.prompt:gsub("\n", " ")
  local prompt_text = M._truncate_prompt(display, available)
  local tag = "[" .. entry.model .. "]"
  local text_w = vim.fn.strdisplaywidth(prompt_text)
  local gap = inner_width - left_pad - text_w - #tag - right_pad
  local line = " " .. prompt_text .. string.rep(" ", math.max(gap, 1)) .. tag .. " "
  table.insert(lines, line)
end
```

**Remove:** `nvim_buf_set_extmark` calls for model tags (lines 359-364). `list_ns` namespace and its `clear_namespace` call become unused — remove.

**Impact on Bug 2:** Fuzzy highlight byte offsets now use `left_pad = 1` instead of `+ 2`.

## Bug 2: Fuzzy Highlight Positions

### Problem

`matchfuzzypos` returns **0-indexed character positions** (not byte positions). Current code at line 372 does:

```lua
local byte_pos = pos + 2  -- wrong: treats char pos as byte pos
...
byte_pos, byte_pos + 1    -- wrong: assumes single-byte character
```

For UTF-8 strings like "переведи" (Cyrillic, 2 bytes/char), character position 3 = byte position 6, but code uses 3+2=5.

Additional problem: `matchfuzzypos` matches against the original `entry.prompt`, but the displayed line uses `display` (newlines replaced with spaces) and may be truncated. Positions from the original string don't map to the displayed text when the string contains newlines or is truncated.

### Solution

Run `matchfuzzypos` against the **display-ready** strings (after newline replacement), not the original prompts. Then convert character positions to byte positions using `vim.fn.byteidx()` on the display line.

**In `apply_filter()`:**

```lua
-- Build display-ready strings for matching
local display_strings = {}
local display_to_entry = {}
for _, e in ipairs(all_entries) do
  local d = e.prompt:gsub("\n", " ")
  table.insert(display_strings, d)
  display_to_entry[d] = e
end
local result = vim.fn.matchfuzzypos(display_strings, text)
local matched = result[1]
local positions = result[2]
-- Store positions keyed by display string
for i, m in ipairs(matched) do
  match_positions[m] = positions[i]
end
-- Build filtered_entries preserving original order
filtered_entries = {}
local matched_set = {}
for _, m in ipairs(matched) do
  matched_set[m] = true
end
for _, e in ipairs(all_entries) do
  local d = e.prompt:gsub("\n", " ")
  if matched_set[d] then
    table.insert(filtered_entries, e)
  end
end
```

**In `render_list()` highlight loop:**

```lua
for i, entry in ipairs(filtered_entries) do
  local display = entry.prompt:gsub("\n", " ")
  local positions = match_positions[display]
  if positions then
    local line_text = lines[i]  -- full padded line: " {text}...{tag} "
    for _, char_pos in ipairs(positions) do
      -- Convert character position in display string to byte position in line
      -- left_pad shifts by 1 character
      local line_char_pos = char_pos + left_pad
      local byte_start = vim.fn.byteidx(line_text, line_char_pos)
      local byte_end = vim.fn.byteidx(line_text, line_char_pos + 1)
      if byte_start >= 0 and byte_end >= 0 then
        pcall(
          vim.api.nvim_buf_add_highlight,
          list_buf, filter_hl_ns, "Search",
          i - 1, byte_start, byte_end
        )
      end
    end
  end
end
```

**Key changes:**
- `match_positions` keyed by display string (after `gsub("\n", " ")`), not `entry.prompt`
- `byteidx()` converts character position to byte position — correct for UTF-8
- `byte_end = byteidx(line, char_pos + 1)` gives correct multi-byte character span
- `left_pad = 1` (from Bug 4 fix) instead of `+ 2`
- `pcall` + bounds check (`>= 0`) protects against truncated lines where positions exceed displayed text

## Bug 1: Active Panel Divider Highlights

### Problem

Entire container border is yellow via `winhl = "FloatBorder:BotglueActiveBorder"`. No per-panel focus indication since inner panels have `border = "none"`.

### Solution

Remove yellow container border. Instead, highlight the divider label of the active panel using extmark-based highlighting on the container buffer.

**Container border:** Remove line 285 (`winhl` setting). Container uses default `FloatBorder` — no yellow.

**Divider highlights:** Replace static `nvim_buf_add_highlight` (lines 263-264) with a function that updates dynamically:

```lua
local divider_ns = vim.api.nvim_create_namespace("botglue_divider")
local divider_rows = {
  list = 1,                  -- "── Recent prompts ──"
  prompt = 2 + list_height,  -- "── Prompt ──"
}

local function update_divider_highlight(active_panel)
  vim.api.nvim_buf_clear_namespace(container_buf, divider_ns, 0, -1)
  for panel, row in pairs(divider_rows) do
    local hl = (panel == active_panel) and ACTIVE_HL or "FloatBorder"
    vim.api.nvim_buf_add_highlight(container_buf, divider_ns, hl, row, 0, -1)
  end
end
```

**Call sites:** Each focus function calls `update_divider_highlight`:
- `focus_list()` → `update_divider_highlight("list")`
- `focus_prompt()` → `update_divider_highlight("prompt")`
- `focus_filter()` → `update_divider_highlight(nil)` — both dividers get `FloatBorder` (no yellow), filter is indicated by cursor + placeholder

**Initial state:** After `focus_list()` at line 669, list divider is yellow.

**`_open_prompt_only`:** No dividers exist, no changes needed. Remove `winhl` from prompt-only container too (line 98).

## Bug 3: Autocomplete Suppression

### Problem

`vim.b[buf].cmp = false` is not the standard variable checked by completion plugins. nvim-cmp checks a custom `enabled` function, blink.cmp checks `vim.b.completion`.

### Solution

Set both known buffer variables for broad compatibility. For each of `filter_buf`, `list_buf`, and `prompt_handle.buf`:

```lua
vim.b[buf].cmp_enabled = false  -- nvim-cmp convention
vim.b[buf].completion = false   -- blink.cmp convention
```

**Existing code already sets these on `filter_buf` and `list_buf`:**
- `picker.lua:298` — `vim.b[filter_buf].cmp = false`
- `picker.lua:318` — `vim.b[list_buf].cmp = false`

**Change:** Replace `vim.b[buf].cmp = false` with both `cmp_enabled = false` and `completion = false` at all three locations.

**Note:** `ui.lua:88` already sets `vim.b[buf].cmp = false` for the prompt buffer — add `cmp_enabled` and `completion` there too, since `create_prompt_window` is the public API used by both `_open_full` and `_open_prompt_only`.

**Files changed:** `picker.lua` (filter_buf, list_buf) and `ui.lua` (prompt buf in `create_prompt_window`).

## Files Changed

- **`lua/botglue/picker.lua`** — Bugs 1, 2, 4, 5: `render_list()` overhaul, `apply_filter()` rework, divider highlight management, focus functions, autocomplete vars
- **`lua/botglue/ui.lua`** — Bug 3 only: add `cmp_enabled` and `completion` buffer vars in `create_prompt_window()`

## Testing Notes

- `render_list` line formatting (Bug 4+5) can be tested indirectly via `_truncate_prompt` — existing tests cover this
- Fuzzy highlight byte conversion (Bug 2) testable via a new helper `M._char_to_byte_positions(line_text, char_positions, left_pad)` extracted from the highlight loop — unit testable with ASCII and UTF-8 inputs
- Divider highlights (Bug 1) require float windows — manual verification only
- Autocomplete (Bug 3) depends on external plugins — manual verification only
- `cursorline` coverage (Bug 5) — manual verification: gray bar must extend across full line including `[model]` tag
