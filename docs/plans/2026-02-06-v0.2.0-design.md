# botglue.nvim v0.2.0 Design

## Vision

Transition from "4 hardcoded operations with notification popups" to "unified inline editing assistant with extmark feedback, project-level context, and Telescope-driven prompt history."

The user stays in their code flow. The AI reads the project, edits the selection, and shows progress inline — not in a separate modal experience.

### Key Design Decisions

| Decision | Choice | Rationale |
|---|---|---|
| Result mode | Always replace selection | Focus on editing, no explain/analysis mode in v0.2.0 |
| File context | Pass file path, Claude reads it | Claude Code has Read/Grep/Glob tools, no need to send file content |
| CLI mode | `-p` with `--output-format stream-json` | Stream activity to extmarks, collect result from text events |
| Tool access | Read-only (`Read,Grep,Glob`) | Claude reads project for context, all writes go through Neovim |
| Picker | Telescope (hard dependency) | Most popular, simplest to implement, no fallback |
| Model selection | Cycle in input window with keymap | Explicit, visible badge, model saved per history entry |
| Progress display | Two extmarks (above + below selection) | Matches ThePrimeagen/99 pattern |

### Reference Implementation

Display and request lifecycle modeled after [ThePrimeagen/99](https://github.com/ThePrimeagen/99):

- `lua/99/ops/marks.lua` — Mark class wrapping extmarks with `virt_lines`
- `lua/99/ops/request_status.lua` — StatusLine (spinner) + RequestStatus (spinner + stdout lines)
- `lua/99/ops/over-range.lua` — Full request lifecycle: marks, status, request, cleanup
- `lua/99/providers.lua` — CLI invocation via `vim.system()`, process tracking, cancellation
- `lua/99/ops/clean-up.lua` — Once-callable cleanup function, active request tracking

---

## Architecture

### File Structure

```
lua/botglue/
  init.lua        — setup(), M.run(), M.cancel(), keymap registration
  config.lua      — defaults: models, timeout, max_turns, ai_stdout_rows
  operations.lua  — get_visual_selection(), replace_selection(), orchestration
  claude.lua      — CLI command builder, process management, stream-json parser, cancel
  ui.lua          — input window (title, model badge, <C-m> cycling)
  display.lua     — NEW: Mark, RequestStatus, extmark lifecycle
  history.lua     — NEW: JSON persistence, frequency sorting, model tracking
  picker.lua      — NEW: Telescope integration

plugin/botglue.lua — :Botglue, :BotglueCancel commands
```

### Data Flow

```
<leader>pp (visual mode)
  → picker.open() — Telescope with history sorted by frequency
  → ui.capture_input() — input window, model badge, <C-m> cycling
  → history.add(prompt, model)
  → operations.run()
    → get_visual_selection()
    → display: place top_mark + bottom_mark extmarks
    → claude.start() — spawn process, stream-json parsing
      → tool-use events → display: push to top_mark lines
      → text_delta events → collect into result
    → on complete: display.clear(), replace_selection(result)
```

### Dependencies

- **Required:** `telescope.nvim`
- **Required:** Claude Code CLI (`claude`) in PATH

---

## 1. Claude Code Invocation

### Command

```bash
claude -p "<user prompt>" \
  --output-format stream-json \
  --verbose \
  --allowedTools "Read,Grep,Glob" \
  --max-turns 3 \
  --model <model> \
  --append-system-prompt "<system prompt>"
```

### Key Flags

| Flag | Purpose |
|---|---|
| `-p` | Non-interactive pipe mode |
| `--output-format stream-json` | Newline-delimited JSON events for streaming activity + result |
| `--verbose` | Full turn-by-turn output (tool calls, thinking) |
| `--allowedTools "Read,Grep,Glob"` | Read-only project access, no writes |
| `--max-turns 3` | Prevent infinite tool-use loops |
| `--append-system-prompt` | Dynamic context (file path, selection, instructions) |
| `--model` | From config default (`opus`) or user selection via cycling |

### System Prompt (dynamic, built per request)

```
You are an inline code editor inside Neovim.
The user selected a region in file: {filepath} (lines {start_line}-{end_line}).
Filetype: {filetype}. Project: {project_name}.

Read the file if you need surrounding context to understand the code.
Modify ONLY the selected region based on the user's request.
Return ONLY the replacement code — no explanations, no markdown fences, no extra text.
The output will directly replace the selection in the editor.
```

### Process Management

```lua
-- claude.lua

-- Start process via vim.fn.jobstart with stdout_buffered = false
-- Parse each stdout line as JSON event:
--   tool-use events → push to display (top extmark)
--   text_delta events → collect into result buffer

M._active_job = nil

function M.cancel()
  if M._active_job and M._active_job > 0 then
    vim.fn.jobstop(M._active_job)
    M._active_job = nil
  end
end
```

### Cancellation

- `<leader>ps` — calls `claude.cancel()`
- Configurable timeout (default: 300s / 5 min) via `vim.uv.new_timer()`, auto-cancels
- On cancel: stop process, clear extmarks, `vim.notify("Cancelled", WARN)`

---

## 2. Inline Progress Display

### Two Extmarks (matching 99 pattern)

```
  ⠹ Processing                 ← top_mark (above selection): spinner + title
  Reading config.lua...        ← stdout lines from Claude (last N lines)
  Analyzing function...

  local M = {}                 ← selected code (untouched during request)
  M.defaults = { ... }

  ⠹ Processing                 ← bottom_mark (below selection): spinner only
```

### Implementation — `display.lua`

Two classes, modeled after 99:

**Mark** — wraps `nvim_buf_set_extmark`:

```lua
local nsid = vim.api.nvim_create_namespace("botglue")

-- Mark.mark_above_range(range) → extmark above first line of selection
-- Mark.mark_point(buffer, end_point) → extmark at end of selection
-- mark:set_virtual_text(lines) → update virt_lines on existing extmark
-- mark:delete() → remove extmark
-- mark:is_valid() → check if extmark still exists
```

**RequestStatus** — spinner animation + streaming lines:

```lua
-- RequestStatus.new(update_time, max_lines, title, mark)
--   update_time: 250ms (spinner interval)
--   max_lines: configurable (ai_stdout_rows, default 5 for top, 1 for bottom)
--   title: "Processing"
--   mark: Mark instance
--
-- status:start() — begins spinner via vim.defer_fn (recursive)
-- status:stop() — sets running = false, stops animation
-- status:push(line) — adds stdout line, evicts oldest if over max_lines
-- status:get() — returns [spinner_line, ...stdout_lines]
```

**Spinner frames:** `{ "⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏" }` at 250ms interval.

**Highlight group:** `Comment` for all virtual text (dim, non-distracting).

### Cleanup

```lua
-- Called on complete, cancel, or error:
top_status:stop()
bottom_status:stop()
top_mark:delete()
bottom_mark:delete()
```

---

## 3. Telescope Picker + Prompt History

### Flow

`<leader>pp` → Telescope picker → select existing or type new → `<CR>` → input window.

### History Storage

File: `~/.local/share/nvim/botglue/history.json`

```json
[
  {
    "prompt": "simplify this function",
    "model": "sonnet",
    "count": 12,
    "last_used": 1738800000
  },
  {
    "prompt": "add error handling",
    "model": "opus",
    "count": 3,
    "last_used": 1738790000
  }
]
```

**Rules:**

- Sorted by `count` descending (most used first)
- Same prompt text = same entry (no duplicates)
- When user reuses a prompt and switches model, entry updates to new model
- `last_used` updates on every use
- New prompts get `count = 1`

### Telescope Picker Display

```
┌─ Botglue ──────────────────────────────────┐
│ > _                                        │
│   simplify this function          [sonnet] │
│   add error handling                [opus] │
│   translate to english             [haiku] │
│   fix naming conventions          [sonnet] │
└────────────────────────────────────────────┘
```

- Model badge on the right: `[sonnet]`, `[opus]`, `[haiku]`
- Telescope fuzzy search for filtering
- `<CR>` on entry → opens input window pre-filled with that prompt
- New text that doesn't match → `<CR>` opens input window with that text
- Empty + `<CR>` → blank input window

### Modules

```lua
-- history.lua
M.load()                    -- read JSON file
M.save()                    -- write JSON file
M.add(prompt, model)        -- add or update entry (count++, last_used, model)
M.get_sorted()              -- return list sorted by count desc

-- picker.lua
M.open(on_select)           -- open Telescope, call on_select({prompt, model})
```

---

## 4. Input Window + Model Selection

### Layout

```
┌─ botglue ──────────────────── [sonnet] ─┐
│ simplify this function                   │
│                                          │
└──────────────────────────────────────────┘
```

### Behaviour

- Title left: `botglue`
- Title right: current model badge `[sonnet]`
- Pre-filled from picker selection, or empty for new prompt
- `<CR>` — submit
- `<S-CR>` — new line (multi-line prompt)
- Model cycle keymap (see research note below) — cycle: sonnet → opus → haiku → sonnet
  - Updates badge in real time
  - Only for this request, does not change config default
- `q` / `<Esc>` — cancel

### On Submit

1. Save to history: `history.add(prompt, current_model)`
2. Close input window
3. Start request flow (operations.run)

---

## 5. Configuration

```lua
require("botglue").setup({
  model = "opus",                          -- default model (Max plan)
  models = { "opus", "sonnet", "haiku" }, -- available for cycling
  default_keymaps = true,                 -- register <leader>pp and <leader>ps
  timeout = 300,                          -- seconds (5 min), auto-cancel
  max_turns = 3,                          -- Claude tool-use turns limit
  ai_stdout_rows = 5,                     -- lines of Claude activity in top extmark
})
```

### Keymaps (visual mode)

| Keymap | Command | Action |
|---|---|---|
| `<leader>pp` | `:Botglue` | Main flow: picker → input → execute |
| `<leader>ps` | `:BotglueCancel` | Cancel running request |

---

## 6. Request Lifecycle (end to end)

```
 1. User selects code in visual mode
 2. <leader>pp
 3. Telescope picker opens (history sorted by frequency)
 4. User picks existing prompt or types new one → <CR>
 5. Input window opens (pre-filled or empty), model badge shown
 6. User optionally edits prompt, cycles model
 7. <CR> submits

 8. Input window closes
 9. history.add(prompt, model)
10. get_visual_selection() — capture selection coordinates
11. Build system prompt (file path, line range, filetype, project name)

12. Place extmarks:
    - top_mark above selection: "⠋ Processing"
    - bottom_mark below selection: "⠋ Processing"
    - Start spinner timers (250ms, vim.defer_fn)

13. Start Claude Code:
    claude -p "<prompt>" \
      --output-format stream-json --verbose \
      --allowedTools "Read,Grep,Glob" \
      --model <model> \
      --max-turns 3 \
      --append-system-prompt "<system prompt>"

14. Stream parsing (stdout, unbuffered):
    - Tool-use events → push to top_mark lines
      ("Reading lua/botglue/config.lua...")
    - text_delta events → collect into result buffer

15. On completion (exit code 0):
    - Stop spinners, delete both extmarks
    - Replace selection with collected result
    - vim.notify short confirmation

16. On error (exit code != 0):
    - Stop spinners, delete extmarks
    - vim.notify error message

17. On cancel (<leader>ps or timeout):
    - SIGTERM to process (jobstop)
    - Stop spinners, delete extmarks
    - vim.notify "Cancelled"
```

---

## 7. What Gets Removed from v0.1.0

### Deleted Code

| File | Removed | Reason |
|---|---|---|
| `claude.lua` | `PROMPTS` table (4 Russian templates) | Replaced by dynamic system prompt |
| `claude.lua` | `build_prompt()` | No more template rendering |
| `claude.lua` | `stdin` piping (`chansend`/`chanclose`) | Prompt goes as CLI argument |
| `operations.lua` | `ResultMode` enum | Always replace, no modes |
| `operations.lua` | `get_context()` | Context built differently |
| `ui.lua` | `show_result_window()` | No explain/window mode |
| `ui.lua` | `start_spinner()` / `stop_spinner()` | Replaced by `display.lua` extmarks |
| `init.lua` | `M.optimize/explain/refactor/translate()` | Single `M.run()` |
| `plugin/botglue.lua` | 4 vim commands | Single `:Botglue` + `:BotglueCancel` |

### Deleted Keymaps

- `<leader>po` (optimize)
- `<leader>pe` (explain)
- `<leader>pr` (refactor)
- `<leader>pt` (translate)

---

## Research Tasks (before implementation)

These must be resolved before writing code:

### 1. `stream-json` parsing

Test `--output-format stream-json --verbose` with `vim.fn.jobstart({ stdout_buffered = false })`:

- What events come through? What is the JSON structure?
- How do tool-use events appear? (e.g., when Claude reads a file)
- How to extract the final result text from the stream?
- Does `--include-partial-messages` add useful data or just noise?

### 2. `--allowedTools` with `-p`

Confirm `Read,Grep,Glob` work in pipe mode:

- Does Claude actually use `Read` to examine the file when given just a path?
- Does `--allowedTools` auto-approve these tools, or just make them available?
- Interaction with `--tools` flag (restrict vs approve).

### 3. `--max-turns` behaviour

- What happens when the turn limit is hit? Error exit code? Partial result?
- Is the text result still returned, or is it lost?

### 4. Model cycling keymap

`<C-m>` in terminal Neovim is the same keycode as `<CR>`. Need alternative:

- Options: `<C-s>`, `<C-l>`, `<Tab>`, `<C-n>`
- Test which keycodes work reliably in insert mode in a floating window

### 5. System prompt effectiveness

- Test whether `--append-system-prompt` instructions ("return only code, no markdown fences") are reliably followed
- Compare result quality with `--system-prompt` (full replacement) vs `--append-system-prompt` (additive)
- Test if Claude Code in `-p` mode auto-discovers project's `.claude/skills/` and `CLAUDE.md`

---

## Implementation Order

```
Phase 1: Foundation
  ├── 1.1 Research: resolve all 5 research tasks above
  ├── 1.2 display.lua — Mark + RequestStatus (extmark-based progress)
  ├── 1.3 claude.lua — rewrite: stream-json, allowedTools, cancel, timeout
  └── 1.4 operations.lua — simplify: single flow, always replace

Phase 2: Input Flow
  ├── 2.1 history.lua — JSON persistence, frequency sorting
  ├── 2.2 picker.lua — Telescope integration
  └── 2.3 ui.lua — rewrite: input window with model badge + cycling

Phase 3: Integration
  ├── 3.1 init.lua — rewrite: setup(), run(), cancel()
  ├── 3.2 plugin/botglue.lua — :Botglue, :BotglueCancel
  ├── 3.3 config.lua — new fields
  └── 3.4 Remove all v0.1.0 legacy code

Phase 4: Testing & Polish
  ├── 4.1 Update tests for new architecture
  ├── 4.2 Update README.md
  ├── 4.3 Update CLAUDE.md
  └── 4.4 make pr-ready
```

Each phase should end with `make pr-ready` passing.

---

## Future (out of scope for v0.2.0)

- **Analysis/explain mode** — separate UX for code explanation (read-only result window)
- **Session continuity** — `--continue` / `--resume` for iterative edits
- **Debug logging** — structured log module with `:BotglueLog` command
- **Streaming result preview** — show replacement text as it streams
- **Skills integration** — bundled `.claude/skills/` for different edit types
