# v0.2.1 UI/UX Improvements Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Overhaul the picker UI with a unified container frame, improved list rendering (extmark model tags, UTF-8 safe truncation, fuzzy highlights), autocomplete suppression, filter placeholder, and focus-loss auto-close.

**Architecture:** Two files change: `lua/botglue/picker.lua` (all tasks) and `lua/botglue/ui.lua` (autocomplete settings, footer removal). The container is a non-focusable background float whose buffer holds divider lines. Inner panels sit inside it with `border = "none"`. Model badge moves from prompt panel footer to container footer.

**Tech Stack:** Lua, Neovim API (`nvim_open_win`, `nvim_buf_set_extmark`, `nvim_create_namespace`), plenary.nvim for testing.

**Design doc:** `docs/plans/2026-02-07-v0.2.1-ui-ux-design.md`

---

### Task 1: Extract helper — `make_divider(label, width)`

A pure function needed by the container. Build and test it first.

**Files:**
- Modify: `lua/botglue/picker.lua:1-5` (add function after requires)
- Test: `test/botglue/picker_spec.lua`

**Step 1: Write the failing test**

Add to `test/botglue/picker_spec.lua` inside the top-level `describe` block, after the existing `describe("module structure")`:

```lua
describe("_make_divider", function()
  it("pads label with ─ to exact width", function()
    local line = picker._make_divider("Recent prompts", 30)
    -- "── Recent prompts " = 19 chars, then 11 × "─" to reach 30
    assert.equals(30, vim.fn.strdisplaywidth(line))
    assert.truthy(line:match("^── Recent prompts ─+$"))
  end)

  it("truncates label if wider than width", function()
    local line = picker._make_divider("Very long label text here", 10)
    assert.equals(10, vim.fn.strdisplaywidth(line))
  end)

  it("works with empty label", function()
    local line = picker._make_divider("", 20)
    assert.equals(20, vim.fn.strdisplaywidth(line))
    assert.truthy(line:match("^─+$"))
  end)
end)
```

**Step 2: Run test to verify it fails**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: FAIL — `_make_divider` is nil.

**Step 3: Write minimal implementation**

Add to `lua/botglue/picker.lua` after line 5 (`local M = {}`):

```lua
--- Build a horizontal divider line: "── Label ────────" padded to width.
--- @param label string section label (e.g. "Recent prompts")
--- @param width number target display width
--- @return string
function M._make_divider(label, width)
  if label == "" then
    return string.rep("─", width)
  end
  local prefix = "── " .. label .. " "
  local prefix_w = vim.fn.strdisplaywidth(prefix)
  if prefix_w >= width then
    return vim.fn.strcharpart(prefix, 0, width)
  end
  return prefix .. string.rep("─", width - prefix_w)
end
```

**Step 4: Run test to verify it passes**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: PASS — all `_make_divider` tests green, existing tests still green.

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua test/botglue/picker_spec.lua
git commit -m "feat(picker): add _make_divider helper for container divider lines"
```

---

### Task 2: Extract helper — `_truncate_prompt(text, max_width)`

Pure function for UTF-8 safe truncation. Replaces the byte-based `string.sub` + `#string` pattern.

**Files:**
- Modify: `lua/botglue/picker.lua` (add function near `_make_divider`)
- Test: `test/botglue/picker_spec.lua`

**Step 1: Write the failing test**

Add to `test/botglue/picker_spec.lua`:

```lua
describe("_truncate_prompt", function()
  it("returns text unchanged if it fits", function()
    assert.equals("hello", picker._truncate_prompt("hello", 20))
  end)

  it("truncates and adds ellipsis when too long", function()
    local result = picker._truncate_prompt("hello world", 8)
    assert.equals("hello w…", result)
    assert.equals(8, vim.fn.strdisplaywidth(result))
  end)

  it("handles UTF-8 characters correctly", function()
    -- "привет" is 6 chars, 6 display width (cyrillic is single-width)
    local result = picker._truncate_prompt("привет мир", 8)
    assert.equals(8, vim.fn.strdisplaywidth(result))
    assert.truthy(result:match("…$"))
  end)

  it("handles CJK double-width characters", function()
    -- "你好世界" is 4 chars, 8 display width
    local result = picker._truncate_prompt("你好世界test", 8)
    assert.equals(8, vim.fn.strdisplaywidth(result))
  end)
end)
```

**Step 2: Run test to verify it fails**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: FAIL — `_truncate_prompt` is nil.

**Step 3: Write minimal implementation**

Add to `lua/botglue/picker.lua` after `_make_divider`:

```lua
--- Truncate prompt text to fit within max_width display columns.
--- Uses strdisplaywidth for correct UTF-8/CJK handling.
--- @param text string prompt text
--- @param max_width number max display columns
--- @return string truncated text (with "…" suffix if truncated)
function M._truncate_prompt(text, max_width)
  if vim.fn.strdisplaywidth(text) <= max_width then
    return text
  end
  -- Binary search would be faster but prompts are short
  local chars = vim.fn.strchars(text)
  for i = chars, 1, -1 do
    local candidate = vim.fn.strcharpart(text, 0, i) .. "…"
    if vim.fn.strdisplaywidth(candidate) <= max_width then
      return candidate
    end
  end
  return "…"
end
```

**Step 4: Run test to verify it passes**

Run: `nvim --headless -u test/minimal_init.lua -c "PlenaryBustedFile test/botglue/picker_spec.lua"`
Expected: PASS.

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua test/botglue/picker_spec.lua
git commit -m "feat(picker): add _truncate_prompt helper with UTF-8 safe truncation"
```

---

### Task 3: Refactor `ui.create_prompt_window` — add `no_border` and `no_footer` options

The container takes over the outer border and model footer. The prompt panel needs to render without them when used inside the container.

**Files:**
- Modify: `lua/botglue/ui.lua:39-70`
- Modify: `lua/botglue/ui.lua:138-156` (set_model, cycle_model — skip footer update when no_footer)
- Test: `test/botglue/ui_spec.lua`

**Step 1: Write the failing test**

Add to `test/botglue/ui_spec.lua` inside `describe("create_prompt_window")`, replacing the existing single `it`:

```lua
describe("create_prompt_window", function()
  it("is a function", function()
    assert.equals("function", type(ui.create_prompt_window))
  end)

  it("sets autocomplete-suppression options on buffer", function()
    -- This test runs only in non-headless (UI required for float windows).
    -- In headless mode, verify the function exists and the options logic is correct.
    -- Autocomplete options are set regardless of UI availability.
    -- We test the pure logic: buffer options should be set after create_prompt_window.
    -- Since we can't open float windows in headless, we test the option-setting helper instead.
    assert.equals("", "") -- placeholder: manual verification required for float windows
  end)
end)
```

> **Note:** Float windows cannot be created in headless Neovim (`nvim_list_uis()` returns `{}`). The `no_border`/`no_footer` behavior requires manual verification. We add the options and test what we can (function signature, pure helpers).

**Step 2: Implement the changes**

In `lua/botglue/ui.lua`, modify `create_prompt_window`:

1. Read new options from `opts`:

```lua
local no_border = opts.no_border or false
local no_footer = opts.no_footer or false
```

2. Change the `nvim_open_win` call — conditionally set border/title/footer:

```lua
local win_opts = {
  relative = "editor",
  width = opts.width,
  height = height,
  row = opts.row,
  col = opts.col,
  style = "minimal",
}
if no_border then
  win_opts.border = "none"
else
  win_opts.border = "rounded"
  win_opts.title = " prompt "
  win_opts.title_pos = "left"
end
if not no_border and not no_footer then
  win_opts.footer = make_footer()
  win_opts.footer_pos = "right"
end

local win = vim.api.nvim_open_win(buf, enter, win_opts)
```

3. After `vim.wo[win].relativenumber = true`, add autocomplete suppression:

```lua
vim.bo[buf].buftype = "nofile"
vim.bo[buf].completefunc = ""
vim.bo[buf].omnifunc = ""
vim.bo[buf].complete = ""
vim.b[buf].cmp = false
```

4. In `handle.set_model` and `handle.cycle_model`, guard the footer update:

```lua
function handle.set_model(model)
  current_model = model
  if not no_footer and handle.is_valid() then
    vim.api.nvim_win_set_config(win, {
      footer = make_footer(),
      footer_pos = "right",
    })
  end
end

function handle.cycle_model()
  current_model = M._next_model(current_model, models)
  if not no_footer and handle.is_valid() then
    vim.api.nvim_win_set_config(win, {
      footer = make_footer(),
      footer_pos = "right",
    })
  end
end
```

**Step 3: Run all tests**

Run: `make test`
Expected: PASS — existing `_next_model` and `_resolve_input` tests unaffected. `create_prompt_window` function still exists.

**Step 4: Commit**

```bash
git add lua/botglue/ui.lua test/botglue/ui_spec.lua
git commit -m "refactor(ui): add no_border/no_footer options, autocomplete suppression"
```

---

### Task 4: Rewrite `_open_prompt_only` with container frame

Replace the bare prompt window with a container + inner prompt.

**Files:**
- Modify: `lua/botglue/picker.lua:30-71` (`_open_prompt_only`)

**Step 1: Rewrite `_open_prompt_only`**

Replace the entire function body:

```lua
function M._open_prompt_only(on_submit)
  setup_highlights()
  local width, col, row = layout_dimensions()

  local current_model = config.options.model
  local models = config.options.models

  local prompt_height = 5
  local container_height = prompt_height

  -- Container (background frame)
  local container_buf = vim.api.nvim_create_buf(false, true)
  vim.bo[container_buf].bufhidden = "wipe"
  -- Fill with empty lines so container is transparent behind prompt
  local container_lines = {}
  for _ = 1, container_height do
    table.insert(container_lines, string.rep(" ", width))
  end
  vim.api.nvim_buf_set_lines(container_buf, 0, -1, false, container_lines)

  local function make_footer()
    return " [" .. current_model .. "] "
  end

  local container_win = vim.api.nvim_open_win(container_buf, false, {
    relative = "editor",
    width = width,
    height = container_height,
    row = row,
    col = col,
    style = "minimal",
    border = "rounded",
    title = " BotGlue ",
    title_pos = "center",
    footer = make_footer(),
    footer_pos = "right",
    focusable = false,
    zindex = 40,
  })
  vim.api.nvim_set_option_value("winhl", "FloatBorder:" .. ACTIVE_HL, { win = container_win })

  -- Prompt panel (inside container, no border)
  local handle = ui.create_prompt_window({
    width = width,
    row = row + 1, -- +1 for container top border
    col = col + 1, -- +1 for container left border
    model = current_model,
    no_border = true,
    no_footer = true,
    zindex = 50,
  })

  local closed = false
  local function close_all()
    if closed then
      return
    end
    closed = true
    handle.close()
    if vim.api.nvim_win_is_valid(container_win) then
      vim.api.nvim_win_close(container_win, true)
    end
  end

  local function update_container_footer()
    if vim.api.nvim_win_is_valid(container_win) then
      vim.api.nvim_win_set_config(container_win, {
        footer = make_footer(),
        footer_pos = "right",
      })
    end
  end

  local function submit()
    local text = vim.trim(handle.get_text())
    close_all()
    if text ~= "" then
      on_submit(text, current_model)
    end
  end

  local buf = handle.buf
  vim.keymap.set("n", "<CR>", submit, { buffer = buf })
  vim.keymap.set({ "i", "n" }, "<C-s>", submit, { buffer = buf })
  vim.keymap.set({ "i", "n" }, "<S-Tab>", function()
    current_model = ui._next_model(current_model, models)
    handle.set_model(current_model)
    update_container_footer()
  end, { buffer = buf })
  vim.keymap.set("n", "<Esc>", close_all, { buffer = buf })
  vim.keymap.set("n", "q", close_all, { buffer = buf })

  -- Close on focus loss
  vim.api.nvim_create_autocmd("WinLeave", {
    buffer = buf,
    callback = function()
      if closed then
        return
      end
      vim.schedule(function()
        if closed then
          return
        end
        local cur = vim.api.nvim_get_current_win()
        if cur ~= handle.win and cur ~= container_win then
          close_all()
        end
      end)
    end,
  })
end
```

**Step 2: Run all tests**

Run: `make test`
Expected: PASS — picker module still loads, exports unchanged.

**Step 3: Manual verification**

Open Neovim with empty history, trigger `:Botglue` in visual mode. Verify:
- Container with "BotGlue" title and `[opus]` footer
- Prompt editor inside, no inner border
- `<S-Tab>` cycles model and updates container footer
- `<Esc>` closes everything
- Clicking outside closes everything

**Step 4: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): rewrite _open_prompt_only with container frame"
```

---

### Task 5: Add `zindex` support to `ui.create_prompt_window`

Task 4 passes `zindex = 50` to the prompt window factory but it's not wired through yet.

**Files:**
- Modify: `lua/botglue/ui.lua:39-65`

**Step 1: Implement**

In `ui.create_prompt_window`, read `opts.zindex` and pass it to `nvim_open_win`:

After building `win_opts` (from Task 3), add:

```lua
if opts.zindex then
  win_opts.zindex = opts.zindex
end
```

**Step 2: Run tests**

Run: `make test`
Expected: PASS.

**Step 3: Commit**

```bash
git add lua/botglue/ui.lua
git commit -m "feat(ui): pass through zindex option to float window"
```

---

### Task 6: Rewrite `_open_full` — container frame, dividers, layout math

The biggest task. Replace individual panel borders with a container + dividers. Preserves all existing keymaps and focus logic, changes only the window creation and layout.

**Files:**
- Modify: `lua/botglue/picker.lua:76-134` (window creation section of `_open_full`)
- Modify: `lua/botglue/picker.lua:200-230` (focus management — remove `set_border_hl` calls)
- Modify: `lua/botglue/picker.lua:234-249` (`close_all` — add container)

**Step 1: Rewrite the window creation section (lines 76–134)**

Replace the panel dimensions + window creation block with:

```lua
function M._open_full(entries, on_submit)
  setup_highlights()
  local width, col, top_row = layout_dimensions()

  -- State
  local all_entries = entries
  local filtered_entries = entries
  local selected_idx = 1
  local draft = { text = "", model = config.options.model }
  local closed = false
  local autocmd_ids = {}

  -- Layout: container interior rows
  local filter_height = 1
  local list_height = math.min(#entries, 10)
  local prompt_height = 5
  local divider_height = 1
  local container_height = filter_height + divider_height + list_height + divider_height + prompt_height

  -- Container (background frame)
  local container_buf = vim.api.nvim_create_buf(false, true)
  vim.bo[container_buf].bufhidden = "wipe"

  -- Build container buffer content: empty rows + divider lines
  local container_lines = {}
  -- Row 0: filter area (covered by filter_win)
  table.insert(container_lines, string.rep(" ", width))
  -- Row 1: divider "── Recent prompts ──────"
  table.insert(container_lines, M._make_divider("Recent prompts", width))
  -- Rows 2..1+list_height: list area (covered by list_win)
  for _ = 1, list_height do
    table.insert(container_lines, string.rep(" ", width))
  end
  -- Row 2+list_height: divider "── Prompt ──────"
  table.insert(container_lines, M._make_divider("Prompt", width))
  -- Rows 3+list_height..end: prompt area (covered by prompt_win)
  for _ = 1, prompt_height do
    table.insert(container_lines, string.rep(" ", width))
  end
  vim.api.nvim_buf_set_lines(container_buf, 0, -1, false, container_lines)

  -- Highlight divider lines with FloatBorder
  local divider_ns = vim.api.nvim_create_namespace("botglue_divider")
  vim.api.nvim_buf_add_highlight(container_buf, divider_ns, "FloatBorder", 1, 0, -1)
  vim.api.nvim_buf_add_highlight(container_buf, divider_ns, "FloatBorder", 2 + list_height, 0, -1)

  local function make_footer()
    return " [" .. draft.model .. "] "
  end

  local container_win = vim.api.nvim_open_win(container_buf, false, {
    relative = "editor",
    width = width,
    height = container_height,
    row = top_row,
    col = col,
    style = "minimal",
    border = "rounded",
    title = " BotGlue ",
    title_pos = "center",
    footer = make_footer(),
    footer_pos = "right",
    focusable = false,
    zindex = 40,
  })
  vim.api.nvim_set_option_value("winhl", "FloatBorder:" .. ACTIVE_HL, { win = container_win })

  -- Inner panel positions (relative to editor, offset by container border)
  local inner_col = col + 1
  local inner_width = width

  -- Panel 1: Filter (row 0 inside container)
  local filter_buf = vim.api.nvim_create_buf(false, true)
  vim.bo[filter_buf].bufhidden = "wipe"
  vim.bo[filter_buf].buftype = "nofile"
  vim.bo[filter_buf].completefunc = ""
  vim.bo[filter_buf].omnifunc = ""
  vim.bo[filter_buf].complete = ""
  vim.b[filter_buf].cmp = false
  local filter_win = vim.api.nvim_open_win(filter_buf, false, {
    relative = "editor",
    width = inner_width,
    height = filter_height,
    row = top_row + 1, -- +1 for container top border
    col = inner_col,
    style = "minimal",
    border = "none",
    zindex = 50,
  })

  -- Panel 2: List (starts at row 2 inside container, after filter + divider)
  local list_buf = vim.api.nvim_create_buf(false, true)
  vim.bo[list_buf].bufhidden = "wipe"
  vim.bo[list_buf].buftype = "nofile"
  vim.bo[list_buf].modifiable = false
  vim.bo[list_buf].completefunc = ""
  vim.bo[list_buf].omnifunc = ""
  vim.bo[list_buf].complete = ""
  vim.b[list_buf].cmp = false
  local list_win = vim.api.nvim_open_win(list_buf, false, {
    relative = "editor",
    width = inner_width,
    height = list_height,
    row = top_row + 1 + filter_height + divider_height,
    col = inner_col,
    style = "minimal",
    border = "none",
    zindex = 50,
  })
  vim.wo[list_win].cursorline = true

  -- Panel 3: Prompt (starts after list + second divider)
  local prompt_handle = ui.create_prompt_window({
    width = inner_width,
    row = top_row + 1 + filter_height + divider_height + list_height + divider_height,
    col = inner_col,
    model = draft.model,
    enter = false,
    no_border = true,
    no_footer = true,
    zindex = 50,
  })
```

**Step 2: Update focus management (remove `set_border_hl` calls)**

Replace `focus_list`, `focus_filter`, `focus_prompt`:

```lua
local function focus_list()
  if vim.api.nvim_win_is_valid(list_win) then
    vim.api.nvim_set_current_win(list_win)
  end
end

local function focus_filter()
  if vim.api.nvim_win_is_valid(filter_win) then
    vim.api.nvim_set_current_win(filter_win)
    vim.cmd("startinsert!")
  end
end

local function focus_prompt(selected_text)
  if selected_text then
    draft.text = selected_text
  end
  prompt_handle.set_draft(draft.text)
  prompt_handle.focus()
end
```

**Step 3: Update `close_all` — add container cleanup**

```lua
local function close_all()
  if closed then
    return
  end
  closed = true
  for _, id in ipairs(autocmd_ids) do
    pcall(vim.api.nvim_del_autocmd, id)
  end
  prompt_handle.close()
  if vim.api.nvim_win_is_valid(list_win) then
    vim.api.nvim_win_close(list_win, true)
  end
  if vim.api.nvim_win_is_valid(filter_win) then
    vim.api.nvim_win_close(filter_win, true)
  end
  if vim.api.nvim_win_is_valid(container_win) then
    vim.api.nvim_win_close(container_win, true)
  end
end
```

**Step 4: Update model cycling keymap to update container footer**

In the `<S-Tab>` keymap for the prompt panel, update the container footer after cycling:

```lua
vim.keymap.set({ "i", "n" }, "<S-Tab>", function()
  prompt_handle.cycle_model()
  draft.model = prompt_handle.get_model()
  if vim.api.nvim_win_is_valid(container_win) then
    vim.api.nvim_win_set_config(container_win, {
      footer = make_footer(),
      footer_pos = "right",
    })
  end
end, { buffer = pbuf })
```

**Step 5: Run tests**

Run: `make test`
Expected: PASS.

**Step 6: Run linter and formatter**

Run: `make lint && make fmt`
Expected: No errors.

**Step 7: Manual verification**

Open Neovim with history entries, trigger `:Botglue` in visual mode. Verify:
- Single container with "BotGlue" title, `[opus]` footer
- Two divider lines: "── Recent prompts ──" and "── Prompt ──"
- Filter, list, prompt panels inside — no inner borders
- Tab cycling, `/` focus, Enter select, Ctrl+S submit all work
- `<S-Tab>` updates container footer
- Esc closes everything

**Step 8: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): rewrite _open_full with container frame and dividers"
```

---

### Task 7: Rewrite `render_list` — extmark model tags + UTF-8 truncation

Replace the padding-based model tag with right-aligned extmarks. Use `_truncate_prompt` for safe truncation.

**Files:**
- Modify: `lua/botglue/picker.lua` (`render_list` function, around line 138)

**Step 1: Add namespace at module top**

After the existing `local ACTIVE_HL` line:

```lua
local list_ns = vim.api.nvim_create_namespace("botglue_list")
```

**Step 2: Rewrite `render_list`**

```lua
local function render_list()
  local lines = {}
  local available = inner_width - 2 -- 2 chars left padding
  for _, entry in ipairs(filtered_entries) do
    local prompt_text = M._truncate_prompt(entry.prompt, available)
    table.insert(lines, "  " .. prompt_text)
  end
  if #lines == 0 then
    lines = { "  (no matches)" }
  end
  vim.bo[list_buf].modifiable = true
  vim.api.nvim_buf_set_lines(list_buf, 0, -1, false, lines)
  -- Clear old extmarks and add model tags
  vim.api.nvim_buf_clear_namespace(list_buf, list_ns, 0, -1)
  for i, entry in ipairs(filtered_entries) do
    vim.api.nvim_buf_set_extmark(list_buf, list_ns, i - 1, 0, {
      virt_text = { { "[" .. entry.model .. "]", "Comment" } },
      virt_text_pos = "right_align",
    })
  end
  vim.bo[list_buf].modifiable = false
  selected_idx = math.max(1, math.min(selected_idx, #filtered_entries))
  if vim.api.nvim_win_is_valid(list_win) and #filtered_entries > 0 then
    vim.api.nvim_win_set_cursor(list_win, { selected_idx, 0 })
  end
end
```

**Step 3: Run tests**

Run: `make test`
Expected: PASS.

**Step 4: Run linter**

Run: `make lint`
Expected: No errors.

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): render model tags as right-aligned extmarks, UTF-8 safe truncation"
```

---

### Task 8: Fuzzy match highlights with `matchfuzzypos`

Replace `matchfuzzy` with `matchfuzzypos` and highlight matched characters in the list.

**Files:**
- Modify: `lua/botglue/picker.lua` (`apply_filter` function + `render_list`)

**Step 1: Add filter highlight namespace at module top**

Next to `list_ns`:

```lua
local filter_hl_ns = vim.api.nvim_create_namespace("botglue_filter_hl")
```

**Step 2: Add state variable for match positions**

In `_open_full`, add to the state section (near `selected_idx`):

```lua
local match_positions = {} -- maps prompt string -> list of byte positions
```

**Step 3: Rewrite `apply_filter`**

```lua
local function apply_filter()
  local text = vim.trim(vim.api.nvim_buf_get_lines(filter_buf, 0, 1, false)[1] or "")
  match_positions = {}
  if text == "" then
    filtered_entries = all_entries
  else
    local prompts = vim.tbl_map(function(e)
      return e.prompt
    end, all_entries)
    local result = vim.fn.matchfuzzypos(prompts, text)
    local matched = result[1]
    local positions = result[2]
    local matched_map = {}
    for i, m in ipairs(matched) do
      matched_map[m] = positions[i]
    end
    filtered_entries = vim.tbl_filter(function(e)
      return matched_map[e.prompt] ~= nil
    end, all_entries)
    for _, e in ipairs(filtered_entries) do
      match_positions[e.prompt] = matched_map[e.prompt]
    end
  end
  selected_idx = 1
  render_list()
  update_preview()
end
```

**Step 4: Add highlight application to `render_list`**

After the model tag extmark loop, add:

```lua
-- Highlight fuzzy match positions
vim.api.nvim_buf_clear_namespace(list_buf, filter_hl_ns, 0, -1)
for i, entry in ipairs(filtered_entries) do
  local positions = match_positions[entry.prompt]
  if positions then
    for _, pos in ipairs(positions) do
      -- pos is 0-indexed byte position in original prompt, offset by 2 for "  " prefix
      local byte_pos = pos + 2
      pcall(vim.api.nvim_buf_add_highlight, list_buf, filter_hl_ns, "Search", i - 1, byte_pos, byte_pos + 1)
    end
  end
end
```

> **Note:** `matchfuzzypos` returns 0-indexed byte positions. We offset by 2 for the `"  "` left padding. The `pcall` guards against positions exceeding the truncated line length.

**Step 5: Run tests**

Run: `make test`
Expected: PASS.

**Step 6: Manual verification**

Open picker with history, type in filter. Verify:
- Matching characters highlighted with `Search` hl group
- Highlights clear when filter is emptied
- Highlights update as you type

**Step 7: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): highlight fuzzy match positions in list using matchfuzzypos"
```

---

### Task 9: Filter placeholder extmark

Show `"Filter recent prompts - press / to focus"` as dimmed overlay in the empty filter field.

**Files:**
- Modify: `lua/botglue/picker.lua` (`_open_full` — after filter_buf creation + inside `apply_filter`)

**Step 1: Add placeholder namespace and helper**

In `_open_full`, after filter_buf creation and autocomplete settings:

```lua
local placeholder_ns = vim.api.nvim_create_namespace("botglue_placeholder")

local function update_placeholder()
  vim.api.nvim_buf_clear_namespace(filter_buf, placeholder_ns, 0, -1)
  local text = vim.api.nvim_buf_get_lines(filter_buf, 0, 1, false)[1] or ""
  if text == "" then
    vim.api.nvim_buf_set_extmark(filter_buf, placeholder_ns, 0, 0, {
      virt_text = { { "Filter recent prompts - press / to focus", "Comment" } },
      virt_text_pos = "overlay",
    })
  end
end
```

**Step 2: Call `update_placeholder` in `apply_filter`**

Add at the end of `apply_filter`, after `update_preview()`:

```lua
update_placeholder()
```

**Step 3: Call `update_placeholder` in initial state**

After `focus_list()` at the end of `_open_full`:

```lua
update_placeholder()
```

**Step 4: Run tests**

Run: `make test`
Expected: PASS.

**Step 5: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): add filter placeholder with navigation hint"
```

---

### Task 10: Close UI on focus loss (`WinLeave` autocmd)

Add `WinLeave` handlers so clicking outside or `<C-w>` switching closes the picker.

**Files:**
- Modify: `lua/botglue/picker.lua` (`_open_full`, autocmds section)

**Step 1: Add `WinLeave` autocmds**

In the autocmds section of `_open_full` (after the existing `TextChangedI` autocmd), add:

```lua
-- Close on focus loss
local our_wins = { filter_win, list_win, prompt_handle.win, container_win }
for _, buf in ipairs({ filter_buf, list_buf, prompt_handle.buf }) do
  table.insert(
    autocmd_ids,
    vim.api.nvim_create_autocmd("WinLeave", {
      buffer = buf,
      callback = function()
        if closed then
          return
        end
        vim.schedule(function()
          if closed then
            return
          end
          local cur = vim.api.nvim_get_current_win()
          for _, w in ipairs(our_wins) do
            if cur == w then
              return
            end
          end
          close_all()
        end)
      end,
    })
  )
end
```

**Step 2: Run tests**

Run: `make test`
Expected: PASS.

**Step 3: Manual verification**

Open picker, then:
1. Click outside with mouse → picker closes
2. Open picker, press `<C-w>w` → picker closes
3. Open picker, Tab between panels → picker stays open
4. Open picker, use `/` then Esc back to list → picker stays open

**Step 4: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "feat(picker): close UI on focus loss via WinLeave autocmd"
```

---

### Task 11: Final cleanup — remove dead code, run `make pr-ready`

**Files:**
- Modify: `lua/botglue/picker.lua` (remove unused `set_border_hl` function if no longer referenced)

**Step 1: Check for dead code**

Search `picker.lua` for `set_border_hl`. If only used in the old focus functions (now removed), delete the function (lines 23-28).

**Step 2: Run full check suite**

Run: `make pr-ready`
Expected: lint PASS, test PASS, format check PASS.

**Step 3: Manual smoke test**

Full flow:
1. Empty history → prompt-only with container
2. After submitting once → full three-panel with container
3. Filter works with highlights
4. Model cycling updates container footer
5. Focus loss closes UI
6. All keymaps work (Tab, /, Enter, Ctrl+S, S-Tab, Esc, q)

**Step 4: Commit**

```bash
git add lua/botglue/picker.lua
git commit -m "chore(picker): remove dead set_border_hl after container refactor"
```
