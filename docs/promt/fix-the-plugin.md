# Баги в botglue.nvim v0.2.0: два критических бага

botglue.nvim — Neovim-плагин для AI-инлайн-редактирования через Claude Code CLI. Пользователь выделяет текст в visual mode, вводит промт, плагин отправляет запрос в Claude Code CLI (команда `claude -p ... --output-format stream-json --verbose`), показывает инлайн-прогресс через extmark-плейсхолдеры и заменяет выделение результатом.

---

## Баг 1. Результат от Claude никогда не вставляется в буфер (FIXED)

### Симптомы

Процесс Claude Code CLI запускается и завершается (exit code 0), но `_extract_result()` возвращает `nil` → пользователь получает ошибку "Empty response from Claude", плейсхолдеры исчезают без замены текста.

### Шаги воспроизведения

1. Выделить текст в visual mode
2. Вызвать `:Botglue`, выбрать или ввести промт, подтвердить
3. Плейсхолдеры (extmark-спиннеры) появляются в буфере
4. Через ~5 мин (таймаут 300 сек) плейсхолдеры исчезают, текст не заменён

### Ожидаемое поведение

1. Плейсхолдеры появляются
2. Под верхним плейсхолдером отображается статус действий Claude (например: "Using Read...", "Using Grep...")
3. После завершения запроса выделенный текст заменяется на результат от Claude

### Корневая причина

Парсер `_extract_result()` в `lua/botglue/claude.lua:137-161` не находит результат в потоке JSON. Проблема в одном или нескольких местах:

**Место 1 — финальный результат (строка 143):** проверяется `parsed.result`, но Claude Code CLI `--output-format stream-json` может возвращать финальный текст в другой структуре (например `parsed.result.text`, `parsed.content`, обёртка `{type: "result", ...}`). Нужно выяснить реальную структуру финального сообщения.

**Место 2 — стриминг text_delta (строки 146-153):** проверяется путь `parsed.type == "stream_event" → parsed.event.delta.type == "text_delta" → parsed.event.delta.text`. Реальный JSON от Claude Code CLI может иметь другую вложенность (например `parsed.event.content_block_delta`, другие имена полей, или `text` лежит в `parsed.event.delta.content`).

**Место 3 — on_stdout (строки 129-135 в operations.lua):** инлайн-статус ловит только `delta.type == "tool_use"`, поэтому если ни tool_use, ни text_delta не матчатся — нет ни статуса, ни результата.

```lua
-- lua/botglue/claude.lua:137-161 — текущий парсер
function M._extract_result(chunks)
  local result_parts = {}
  for _, chunk in ipairs(chunks) do
    local ok, parsed = pcall(vim.json.decode, chunk)
    if ok and parsed then
      if parsed.result then
        return parsed.result           -- ← проверить: какая реальная структура?
      end
      if
        parsed.type == "stream_event"
        and parsed.event
        and parsed.event.delta
        and parsed.event.delta.type == "text_delta"  -- ← проверить: реальный путь?
      then
        table.insert(result_parts, parsed.event.delta.text)  -- ← проверить: .text?
      end
    end
  end
  if #result_parts > 0 then
    return table.concat(result_parts, "")
  end
  return nil
end
```

### Задача

1. Запустить `claude -p "test" --output-format stream-json --verbose` вручную и изучить реальную структуру JSON-вывода — как выглядят стриминговые события (text content) и финальное сообщение с результатом
2. Привести `_extract_result()` и `on_stdout` в соответствие с реальным форматом
3. Убедиться, что `on_stdout` callback в `operations.lua:129-135` тоже корректно парсит события для отображения статуса
4. Добавить тесты для `_extract_result()` с реальными данными из CLI

---

## Баг 2. Нельзя запускать несколько запросов параллельно (FIXED)

### Симптомы

При попытке запустить второй запрос (на другом выделении) появляется ошибка: `"Another request is already running"`.

### Ожидаемое поведение (по дизайну v0.2.0)

Параллельные запросы — ключевая фича: пользователь выделяет фрагмент A, запускает промт → плейсхолдеры A появляются → выделяет фрагмент B, запускает другой промт → плейсхолдеры B появляются → оба работают независимо, каждый заменяет свой фрагмент по завершении.

### Текущее поведение

1. Пользователь выделяет текст A, запускает промт → плейсхолдеры появляются
2. Пользователь выделяет текст B, запускает промт → ошибка "Another request is already running"

### Корневая причина

Модуль `claude.lua` хранит состояние в единственных модульных переменных — один слот на всё:

```lua
-- lua/botglue/claude.lua:5-7
M._active_job = nil      -- один job_id
M._timeout_timer = nil   -- один таймер
M._cancel_reason = nil   -- одна причина отмены
```

Гард на строке 59-62 блокирует любой новый запрос, пока первый не завершился:

```lua
-- lua/botglue/claude.lua:59-62
if M._active_job and M._active_job > 0 then
  observer.on_complete("Another request is already running", nil)
  return
end
```

Аналогично `operations.lua:109` хранит единственный `M._cleanup`, а `cancel()` отменяет единственный процесс.

### Задача

Рефакторинг `claude.lua` и `operations.lua` для поддержки множественных параллельных запросов:

1. **`claude.lua`:** заменить модульные синглтоны (`M._active_job`, `M._timeout_timer`, `M._cancel_reason`) на per-request объект/таблицу. `start()` должен возвращать handle (например `{job_id, timer, cancel()}`) вместо записи в модульное состояние. Удалить гард "Another request is already running".
2. **`operations.lua`:** `run()` должен хранить cleanup-функцию per-request (локально или в списке), а не в `M._cleanup`. `cancel()` должен отменять все активные запросы или принимать аргумент для отмены конкретного.
3. **Таймауты:** каждый запрос должен иметь свой независимый таймер.
4. Обновить тесты для проверки параллельного запуска двух запросов.

---

# Дизайн-план: рефакторинг UI/UX botglue.nvim

## Контекст проекта

botglue.nvim — Neovim-плагин для AI-инлайн-редактирования через Claude Code CLI. Пользователь выделяет текст в visual mode, выбирает или пишет промт, плагин отправляет запрос в Claude и заменяет выделение результатом.

### Текущая архитектура UI (что менять)

Сейчас UI состоит из двух последовательных шагов:

1. **Picker** (`picker.lua`) — Telescope-пикер со списком сохранённых промтов. Пользователь либо выбирает промт из списка, либо вводит текст в строку фильтра и нажимает Enter. После выбора Telescope закрывается.
2. **Input** (`ui.lua`) — Плавающее окно ввода (3 строки, `border: rounded`). Если пользователь выбрал существующий промт — он подставляется в окно. Кейбинды: `Enter` — отправить (в insert и normal mode), `Shift+Enter` — перенос строки, `Ctrl+S` — переключение модели, `q`/`Esc` — отмена.

Поток вызова: `init.lua:M.run()` → `picker.open(callback)` → `ui.capture_input(opts, on_submit, on_cancel)` → `operations.run(prompt, model, sel)`.

### Связанные модули (не менять)

- `config.lua` — дефолты: модель `opus`, список `{ "opus", "sonnet", "haiku" }`, timeout 300s, ai_stdout_rows 5
- `history.lua` — JSON-персистенция промтов с частотой и сортировкой
- `display.lua` — extmark-спиннеры, inline-прогресс
- `operations.lua` — оркестрация запросов к Claude CLI
- `claude.lua` — CLI-интерфейс к Claude

## Проблемы текущего UI

### 1. Фокус в Telescope
При открытии Telescope фокус стоит на строке фильтра (поведение по умолчанию). Для плагина, где основной сценарий — выбор из списка частых промтов, фокус должен быть на списке результатов.

### 2. Размер окна результатов Telescope
Список результатов Telescope растягивается на полстраницы, даже если в истории 2-3 промта. Нужно ограничить высоту списка (max 10 строк) с подстройкой под реальное количество элементов.

### 3. Навигация по списку только стрелками
Когда фокус на строке фильтра, навигация по списку результатов возможна только стрелками. Нужно добавить `Ctrl+j` / `Ctrl+k` для перемещения по списку без потери фокуса с фильтра.

### 4. Навигация в режиме фокуса на результатах
Когда фокус на списке результатов, `j`/`k` должны перемещать выделение. Активное поле (фильтр или результаты или промт) должно подсвечиваться жёлтым бордером.

### 5. Поле ввода промта появляется отдельным шагом
Сейчас поле ввода промта — отдельное плавающее окно, которое открывается только после закрытия Telescope. Нужно: единый интерфейс, где список истории и поле ввода промта видны одновременно, друг под другом.

### 6. Переход из списка в поле ввода
При нажатии `Enter` с фокусом на списке результатов — выбранный промт подставляется в поле ввода и фокус переходит туда для возможного редактирования перед отправкой.

### 7. Номера строк в поле ввода
В поле Prompt нужно отображать номера строк (`number = true`) для удобного использования motion-команд Neovim при редактировании многострочных промтов.

### 8. Enter/Shift+Enter перепутаны
Сейчас `Enter` в поле Prompt отправляет промт, `Shift+Enter` — тоже отправляет промт. Это неинтуитивно: `Enter` должен вставлять перенос строки (стандартное поведение в текстовом буфере Neovim), `Shift+Enter` — отправлять промт.

### 9. Ctrl+M не работает как переключение модели
`Ctrl+M` в терминале — это `Enter` (одинаковый keycode), поэтому он закрывает окно. Переключение модели нужно перенести с `Ctrl+S` на `Shift+Tab` (при фокусе на поле Prompt), а в footer отображать текущую модель.

## Задача

Спроектировать единый UI-компонент, объединяющий список истории и поле ввода промта в одном окне. Написать дизайн-план, охватывающий:

1. **Раскладка окон** — как расположить список истории промтов и поле ввода промта (один float-window или два стыкованных). Размеры, пропорции, адаптация к количеству элементов истории.

2. **Управление фокусом** — как пользователь переключается между списком истории и полем ввода. Визуальная индикация активного поля (highlight-группы для бордера).

3. **Карта кейбиндов** — полная таблица хоткеев для каждого поля с учётом normal/insert mode:
   - Навигация по списку: `j`/`k` (normal в списке), `Ctrl+j`/`Ctrl+k` (из фильтра)
   - Переключение фокуса между полями
   - `Enter` в списке → подставить промт и перевести фокус на поле Prompt
   - `Enter` в поле Prompt → перенос строки
   - `Shift+Enter` в поле Prompt → отправить промт
   - `Shift+Tab` в поле Prompt → переключить модель
   - `Esc`/`q` → закрыть всё
   - Фильтрация списка при вводе текста

4. **Сценарии использования** — пошагово описать три основных пользовательских пути:
   - Выбрать существующий промт и отправить без изменений
   - Выбрать существующий промт, отредактировать, отправить
   - Написать новый промт с нуля и отправить

5. **Решение по реализации** — оставлять ли Telescope (кастомизация layout + mappings) или заменить на кастомный float-window UI. Аргументы за и против с учётом зависимости проекта от Telescope.



 Implementation Complete

  7 commits implementing the three-panel UI refactor:
  ┌─────────┬───────────────────────────────────────────────────────────────────┐
  │ Commit  │                            Description                            │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ df05f57 │ ui.lua → panel 3 factory with create_prompt_window                │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ f4b8144 │ picker.lua → three-panel orchestrator (Telescope + prompt editor) │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ 312412b │ init.lua simplified + BotglueCancel removed                       │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ f375d6d │ Tests updated (_extract_result tuple, selected_text ctx)          │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ 4212220 │ Design doc — implementation status                                │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ bcc68cc │ CLAUDE.md — new architecture                                      │
  ├─────────┼───────────────────────────────────────────────────────────────────┤
  │ c8105dd │ Code review fixes (deprecated API, border hl, README)             │
  └─────────┴───────────────────────────────────────────────────────────────────┘
  Verification: 64 tests passing, 0 lint errors, format clean.

  Manual smoke test needed: Restart Neovim and test the 6 scenarios from the design doc:
  - A: Quick submit from list (Shift+Enter)
  - B: Select + edit + submit
  - C: Filter → select → submit
  - D: New prompt from scratch (Tab → type → Shift+Enter)
  - E: Draft persistence (edit → browse → restore)
  - F: Empty history (only prompt editor)

✻ Sautéed for 4m 50s

❯ ты все сделал как было описно в плане? все закончил?

● Нет, не всё. Осталось:

  1. Ретроспектива (Task 14 из плана) — анализ процесса + предложения по улучшению. Это было в твоём запросе: "проанализируй
  выполнение задачи и предложи улучшения".
  2. Ручной smoke test — тебе нужно перезапустить Neovim и протестировать 6 сценариев (A-F). Автоматические тесты не покрывают UI с
  float-окнами.
  3. Finishing — по процессу subagent-driven development нужно использовать superpowers:finishing-a-development-branch.

  Давай закончу ретроспективу сейчас:

  ---
Теперь я вижу текст, который нужно исправить. Вот исправленная версия:

Ретроспектива

Использованный процесс: brainstorming → writing-plans → subagent-driven-development (implementer + spec-reviewer + code-reviewer для каждой задачи)

Теперь я вижу контекст. Нужно переделать выбранный текст (строки 251-254) в нумерованный список. Вот замена:

1. Параллельное выполнение задач 5, 6, 7 одновременно — сэкономили ~3 минуты
2. Код-ревью обнаружил 3 реальных бага (deprecated API, border race condition, README)
3. Spec-ревью подтвердил соответствие дизайну

Что было медленно:
- Ручное UI-тестирование невозможно автоматизировать в headless-режиме — 6 сценариев требуют проверки вручную
- Каждый subagent заново читает файлы (нет общего контекста между агентами)

  Предложения по улучшению:

  1. Hook pre-commit-format — автоматический make fmt перед каждым коммитом. Убрал бы отдельные шаги форматирования из плана.
  2. Hook post-commit-lint — make lint после каждого коммита для мгновенной обратной связи.
  3. Custom skill telescope-plugin-patterns — документирование паттернов работы с Telescope internals (attach_mappings, actions.close
  override, layout_strategy, nvim_win_get_config quirks). Ускорит будущую работу с UI.
  4. Custom skill ui-smoke-test — генерация скрипта для полуавтоматического тестирования UI через nvim --listen + RPC. Не полная
  автоматизация, но структурированный чеклист с командами.
  5. Custom agent parallel-test-runner — запуск каждого *_spec.lua параллельно для сокращения общего времени тестов.

  ---
  Хочешь перейти к smoke test или сначала реализовать какое-то из улучшений?

---

# Ассистент по улучшению промтов для инлайн-редактирования

Ты — опытный промт-инженер, специализирующийся на промтах для LLM в контексте инлайн-редактирования кода в редакторах. Твоя задача — проанализировать предоставленный промт и улучшить его так, чтобы LLM выдавал максимально качественный результат при инлайн-замене выделенного текста.

## Контекст использования

Этот скилл применяется в сценарии инлайн-редактирования: пользователь выделяет текст в редакторе, вводит промт, система отправляет его в LLM и заменяет выделение результатом. Промт передаётся как есть — результат должен быть готовым к прямой вставке в буфер редактора.

## Вход

<original_prompt>
{{PROMPT}}
</original_prompt>

## Процесс

### Шаг 1: Диагностика
Перед изменениями проведи анализ исходного промта:
- **Ясность цели**: Явно ли указан конечный результат? Что именно пользователь хочет получить в буфере?
- **Неоднозначности**: Какие формулировки LLM может интерпретировать двояко? (например: "улучши" — по какому критерию?)
- **Недостающий контекст**: Какая информация подразумевается, но не указана? (язык программирования, фреймворк, стиль кода)
- **Структура**: Логичен ли порядок инструкций? Нет ли противоречий?
- **Формат вывода**: Указано ли, что результат должен быть готовым кодом/текстом без обёрток, пояснений и markdown-блоков?
- **Граничные случаи**: Что может заставить LLM выдать лишний текст, комментарии к изменениям или markdown-обёртку вместо чистого результата?

Выдай анализ кратким списком (3–7 пунктов).

### Шаг 2: Улучшение
Перепиши промт, применяя следующие принципы:

1. **Явная цель** — начни с чёткого описания ожидаемого результата и его формата. Для инлайн-замены: «Результат — готовый код/текст, который заменит выделенный фрагмент».
2. **Роль и контекст** — назначь подходящую экспертную роль. Укажи контекст, необходимый для качественного выполнения (язык, фреймворк, стиль кода, если это следует из промта).
3. **Декомпозиция** — для сложных задач разбей на последовательные шаги. Каждый шаг — с конкретным результатом.
4. **Конкретность** — замени размытые слова («хороший», «интересный», «улучши») на измеримые критерии или примеры.
5. **Формат ввода/вывода** — опиши ожидаемую структуру результата (формат, секции, длина). Для инлайн-замены обязательно: «Выдай ТОЛЬКО замену, без пояснений, без markdown-блоков, без комментариев к изменениям».
6. **Ограничения и границы** — укажи, чего избегать, чего не делать, какие рамки соблюдать.
7. **Примеры** — если уместно, добавь краткий пример желаемого вывода (few-shot).
8. **Самопроверка** — добавь инструкцию для LLM проверить свой результат перед выдачей: «Убедись, что вывод содержит только готовый текст для замены, без обёрток и пояснений».

### Шаг 3: Результат

Выдай:
1. **Анализ** — краткий список найденных проблем (3–7 пунктов).
2. **Улучшенный промт** — готовый к использованию переписанный промт в блоке кода.
3. **Лог изменений** — список того, что было изменено и почему (чтобы пользователь мог понять и скорректировать).

## Правила
- Сохраняй исходный замысел. Не добавляй задач, которых пользователь не ставил.
- Если исходный промт написан не на русском — сохраняй язык оригинала в улучшенном промте.
- Помни контекст использования: результат промта будет напрямую вставлен в буфер редактора через замену выделенного текста. Промт должен это учитывать.
- Предпочитай ясность краткости — лучше указать явно, чем надеяться на «угадывание» LLM.
- Не усложняй простые промты. Если задача тривиальна — минимальных улучшений достаточно.

---

Now I have all the context needed. Here's the optimized prompt:

---

# Дизайн-план: UI/UX-доработки botglue.nvim v0.2.1

## Контекст проекта

botglue.nvim — Neovim-плагин для AI-инлайн-редактирования через Claude Code CLI. Пользователь выделяет текст в visual mode, выбирает или пишет промт через трёхпанельный UI, плагин отправляет запрос в Claude и заменяет выделение результатом.

### Текущая архитектура UI

Трёхпанельный интерфейс из кастомных float-окон (`picker.lua` + `ui.lua`):

- **Panel 1 — Filter** (`filter_buf`/`filter_win`): однострочное поле для fuzzy-фильтрации истории промтов через `vim.fn.matchfuzzy`. Создаётся в `_open_full()` строка 98–110.
- **Panel 2 — List** (`list_buf`/`list_win`): список промтов из `history.get_sorted()`, отсортированных по частоте. Каждая строка: текст промта + `[model]` тег, выровненный вправо. Создаётся в `_open_full()` строка 113–125. Рендеринг — функция `render_list()` строка 138–163.
- **Panel 3 — Prompt** (`prompt_handle` от `ui.create_prompt_window`): многострочный редактор промта с footer-бейджем текущей модели (`[opus]`), `relativenumber`, `wrap`. Создаётся в `_open_full()` строка 128–134.

Панели расположены вертикально друг под другом, каждая в отдельном float-окне с рамкой `border = "rounded"`. Активная панель выделяется жёлтой рамкой (`BotglueActiveBorder → DiagnosticWarn`). Навигация: `Tab` — переключение фокуса между панелями, `/` — переход в фильтр, `Enter` — выбор из списка в промт, `Ctrl+S` — быстрая отправка.

При пустой истории открывается только Panel 3 (`_open_prompt_only()`).

### Затронутые модули

- `lua/botglue/picker.lua` — оркестратор трёх панелей, фокус, кеймапы, рендеринг списка
- `lua/botglue/ui.lua` — фабрика Panel 3 (prompt editor), предпросмотр, draft, модель

### Не затрагиваемые модули

- `config.lua`, `history.lua`, `display.lua`, `operations.lua`, `claude.lua`, `init.lua`

## Задачи (8 пунктов)

### 1. Отключить автодополнение во всех панелях

**Проблема:** Встроенный Neovim-автокомплит (`ins-completion`) срабатывает при вводе текста в Panel 1 (Filter) и Panel 3 (Prompt), мешая быстрому набору.

**Что сделать:** Для всех буферов трёх панелей (`filter_buf`, `list_buf`, `prompt_handle.buf`) установить `vim.bo[buf].complete = ""` и `vim.bo[buf].omnifunc = ""`, а также при необходимости `vim.bo[buf].completefunc = ""`. Это предотвратит вызов автодополнения. Если проблема вызвана внешним плагином (nvim-cmp, coq и т.п.) — добавить `vim.b[buf].cmp = false` (для nvim-cmp) и/или установить `vim.bo[buf].buftype = "nofile"` (уже установлено через `bufhidden = "wipe"`, но проверить наличие `buftype`).

**Файл:** `picker.lua` (`_open_full`, `_open_prompt_only`), `ui.lua` (`create_prompt_window`).

### 2. Объединяющая рамка с заголовком "BotGlue"

**Проблема:** Три панели визуально разрознены — каждая имеет свою индивидуальную рамку, нет общего контейнера.

**Что сделать:** Создать фоновый float-окно (декоративный контейнер) размером, охватывающим все три панели, с `border = "rounded"` и `title = " BotGlue "`. Это окно открывается первым (z-order ниже), не принимает фокус (`focusable = false`), буфер пустой. У внутренних панелей заменить `border = "rounded"` на `border = { "", "─", "", "", "", "─", "", "" }` (только горизонтальные разделители) или `"none"`, чтобы не дублировать рамки. При закрытии (`close_all`) также закрывать контейнер.

**Файл:** `picker.lua` (`_open_full`, `close_all`, расчёт позиций).

### 3. Заголовки (title) для каждой панели

**Проблема:** Панели не подписаны — непонятно их назначение, особенно для новых пользователей.

**Что сделать:** Установить `title` при создании каждого float-окна:
- Panel 1: `title = " Filter recent prompts "`, `title_pos = "left"`
- Panel 2: `title = " Recent prompts "`, `title_pos = "left"`
- Panel 3: уже имеет `title = " prompt "` — заменить на `title = " Prompt "`, `title_pos = "left"`

**Файл:** `picker.lua` (строки 100–110, 116–124), `ui.lua` (строка 61).

### 4. Подсветка совпадений при фильтрации

**Проблема:** При вводе текста в Filter список фильтруется через `matchfuzzy`, но найденные символы/подстроки не выделяются визуально в строках списка.

**Что сделать:** Заменить `vim.fn.matchfuzzy` на `vim.fn.matchfuzzypos`, который возвращает не только совпавшие строки, но и позиции совпавших символов. В функции `render_list()` после записи строк в буфер — добавить highlight через `nvim_buf_add_highlight` (namespace `botglue_filter_match`) для каждой совпавшей позиции символа. Использовать highlight-группу `Search` или создать свою `BotglueMatch`. Очищать namespace перед каждым рендером.

**Файл:** `picker.lua` (`apply_filter`, `render_list`).

### 5. Разнесение текста промта и модели в списке

**Проблема:** В текущем рендере (`render_list()`) текст промта и тег модели `[opus]` записаны в одну строку через пробелы. Визуально они сливаются.

**Что сделать:** Вместо записи единой строки — использовать extmark-based виртуальный текст (`virt_text` с `virt_text_pos = "right_align"`) для тега модели. Промт записывается как обычный текст строки, а `[model]` — через `nvim_buf_set_extmark` с `virt_text = { { "[opus]", "Comment" } }`, выровненный вправо. Это визуально разнесёт их и позволит использовать разные highlight-группы.

**Файл:** `picker.lua` (`render_list`).

### 6. Плейсхолдер в Panel 2 (List) с подсказкой навигации

**Проблема:** При открытии фокус на списке, но пользователь не знает, как перейти к фильтру.

**Что сделать:** Добавить виртуальный текст (`virt_text`) в Panel 2 (List) — однострочный плейсхолдер, который показывается когда фокус на списке. Текст: `Press / to filter...`. Реализовать через `nvim_buf_set_extmark` с `virt_text` в конце последней строки или через `virt_lines_above`. Скрывать при фильтрации (когда Filter непуст). Можно использовать highlight-группу `Comment` (приглушённый текст).

**Файл:** `picker.lua` (в `render_list` или рядом с `focus_list`).

### 7. Исправить символ обрезки длинных промтов

**Проблема:** Длинные промты обрезаются в `render_list()` (строка 144–145): `prompt_text:sub(1, available - 1) .. "…"`. Символ `…` (Unicode ellipsis, U+2026) — один символ, но Lua `#string` считает его как 3 байта (UTF-8). Из-за этого расчёт `padding` может стать отрицательным или некорректным, и в строке появляется артефакт.

**Что сделать:** Заменить `#prompt_text` на `vim.fn.strdisplaywidth(prompt_text)` для корректного расчёта ширины, либо использовать `vim.fn.strcharlen`. Аналогично для `#model_tag`. Также учесть, что `string.sub` обрезает по байтам — использовать `vim.fn.strcharpart(prompt_text, 0, available - 1)` для корректной обрезки UTF-8. Если задача 5 реализована (модель через extmark), этот расчёт упрощается, т.к. модель больше не в строке.

**Файл:** `picker.lua` (`render_list`, строки 140–151).

### 8. Закрытие UI при потере фокуса на основной буфер

**Проблема:** Если пользователь кликает мышью или через `<C-w>` переключается на основной буфер — окна плагина остаются висеть.

**Что сделать:** Добавить `WinLeave` autocmd на все три буфера панелей. В callback проверять с `vim.schedule` (чтобы Neovim успел обновить текущее окно): если `vim.api.nvim_get_current_win()` не является ни `filter_win`, ни `list_win`, ни `prompt_handle.win` — вызвать `close_all()`. Использовать `vim.schedule` обязательно, т.к. на момент `WinLeave` текущее окно ещё не обновлено.

**Файл:** `picker.lua` (`_open_full`, секция autocmds, строки 351–381).

## Порядок реализации

Рекомендуемый порядок с учётом зависимостей:

1. **Задача 7** (символ обрезки) — исправление бага, не зависит от других задач
2. **Задача 5** (разнесение промта и модели) — упрощает расчёт ширины в render_list
3. **Задача 4** (подсветка совпадений) — зависит от нового формата render_list
4. **Задача 1** (автокомплит) — независимая, минимальная
5. **Задача 3** (заголовки панелей) — независимая, минимальная
6. **Задача 6** (плейсхолдер) — независимая, минимальная
7. **Задача 8** (закрытие при потере фокуса) — независимая
8. **Задача 2** (общая рамка) — самая сложная, затрагивает layout всех панелей

Помоги составить дизайн-план на их реализацию.


---

- если окно промта без истории и поска надо писать туда понятный плейсхолдер которы рассказывает - Put your promt here...

---

## Задача

Реализовать план `docs/plans/2026-02-07-v0.2.1-ui-ux-implementation.md` (11 задач) от начала до конца без остановок.

**Проект:** botglue.nvim — Neovim-плагин для AI-инлайн-редактирования через Claude Code CLI.  
**Дизайн-документ:** `docs/plans/2026-02-07-v0.2.1-ui-ux-design.md`  
**Затронутые файлы:** `lua/botglue/picker.lua`, `lua/botglue/ui.lua`, `test/botglue/picker_spec.lua`, `test/botglue/ui_spec.lua`

## Дополнение к плану

В `_open_prompt_only` (режим пустой истории — только окно промта без списка и фильтра) добавить placeholder-extmark в буфер промта: `"Type your prompt here..."` с highlight-группой `Comment` и `virt_text_pos = "overlay"`. Placeholder скрывается при первом вводе текста (через `TextChangedI` autocmd), восстанавливается при пустом буфере.

## Требования к процессу выполнения

### 1. Параллельное выполнение независимых задач

План содержит задачи с разным уровнем зависимостей. Разбей на параллельные группы:

- **Группа A (независимые хелперы, запускать параллельно):** Task 1 (`_make_divider`), Task 2 (`_truncate_prompt`), Task 3 (рефакторинг `ui.create_prompt_window` — `no_border`/`no_footer`/autocomplete), Task 5 (`zindex` support)
- **Группа B (зависят от группы A):** Task 4 (`_open_prompt_only` с контейнером), Task 6 (`_open_full` с контейнером)
- **Группа C (зависят от группы B):** Task 7 (extmark model tags + UTF-8 truncation в `render_list`), Task 8 (fuzzy highlights через `matchfuzzypos`), Task 9 (filter placeholder), Task 10 (WinLeave autocmd)
- **Группа D (финализация):** Task 11 (dead code cleanup + `make pr-ready`)

Каждому сабагенту передавать ссылку на общий план (`docs/plans/2026-02-07-v0.2.1-ui-ux-implementation.md`) и дизайн-документ (`docs/plans/2026-02-07-v0.2.1-ui-ux-design.md`), чтобы агент понимал полный контекст архитектурных решений и мог корректно реализовать свою часть.

### 2. Тестирование

- Каждая задача плана содержит шаги "Write the failing test" → "Run test" → "Implement" → "Run test". Следовать TDD-циклу строго.
- После каждой группы задач запускать `make test` и убедиться, что все тесты (включая существующие 62) проходят.
- После завершения всех задач запустить `make pr-ready` (lint + test + format check) — всё должно быть зелёным.

### 3. Обновление документации

После реализации всех задач:
- Обновить `CLAUDE.md`: секцию "UI Architecture" (описать container frame + dividers + inner panels без индивидуальных бордеров), секцию "Gotchas" (добавить заметку про container zindex и WinLeave + vim.schedule), таблицу тестов (обновить количество тестов в `picker_spec.lua` и `ui_spec.lua`).
- Обновить секцию "Dependencies" — если Telescope больше не нужен, отразить это.

### 4. Код-ревью

После завершения реализации использовать скилл `superpowers:requesting-code-review`. Все критические проблемы, найденные ревью, исправить и перезапустить `make pr-ready`.

### 5. Ретроспектива процесса

После успешного код-ревью проанализировать процесс выполнения и предложить конкретные улучшения:
- **Хуки (hooks):** какие pre-commit/post-commit хуки ускорили бы работу (автоформатирование, линтинг, проверка тестов).
- **Скиллы (skills):** какие повторяющиеся паттерны стоит оформить как скиллы (паттерны работы с float-окнами Neovim, extmark API, TDD-цикл для Lua/plenary).
- **Агенты (agents):** какие задачи можно было распараллелить лучше, какие агенты могли бы работать эффективнее с другой конфигурацией.

## Порядок действий

1. Прочитать план целиком: `docs/plans/2026-02-07-v0.2.1-ui-ux-implementation.md`
2. Прочитать дизайн-документ: `docs/plans/2026-02-07-v0.2.1-ui-ux-design.md`
3. Прочитать текущий код: `lua/botglue/picker.lua`, `lua/botglue/ui.lua`
4. Выполнить группу A (Tasks 1, 2, 3, 5) параллельно
5. Выполнить группу B (Tasks 4, 6) — последовательно, каждая зависит от группы A
6. Выполнить группу C (Tasks 7, 8, 9, 10) — Tasks 7→8 последовательно, Tasks 9 и 10 параллельно
7. Выполнить группу D (Task 11) — cleanup + `make pr-ready`
8. Добавить prompt placeholder в `_open_prompt_only` (дополнение к плану)
9. Обновить `CLAUDE.md`
10. Запустить код-ревью (`superpowers:requesting-code-review`), исправить найденные проблемы
11. Провести ретроспективу, записать предложения по улучшению хуков/скиллов/агентов

---

● All implementation complete. Final state:

  8 commits (935a2fc..3af9cbb)
  71 tests, 0 failures
  make pr-ready: all checks passed

  Process Retrospective

  What went well

  - Parallel Group A worked perfectly — Tasks 1+2 (picker.lua) and Tasks 3+5 (ui.lua) ran in parallel with no file conflicts, saving
  ~75 seconds.
  - Task consolidation was effective — the _open_full rewrite naturally integrated Tasks 7 (extmark model tags), 9 (filter
  placeholder), and 10 (WinLeave), reducing 11 plan tasks to 6 subagent dispatches.
  - Code review caught real bugs — the placeholder not being restored on filter clear (I-2) was a functional bug that would have been
  visible to users.

  Proposed improvements

  Hooks:
  - pre-commit: run make fmt-check to catch unformatted code before commit
  - pre-commit: run make lint to catch luacheck warnings
  - Post-implementation: a make test hook after each file save in the botglue module would catch regressions instantly

  Skills:
  - neovim-float-ui — pattern for creating container + inner panels with zindex layering, divider lines, and border management. This
  same pattern (background frame + borderless inner panels) appears frequently in Neovim plugin development.
  - lua-tdd-plenary — TDD cycle for Lua/plenary with module reload patterns, headless limitations awareness, mock patterns.

  Agents:
  - The _open_full rewrite was too large for one subagent prompt — it worked but the subagent had to be given the complete replacement
   code. For such large rewrites, a two-stage approach (scaffold first, then fill in functions) might be more reliable.
  - Spec review and code quality review could be combined into a single pass for smaller tasks (helpers, config changes) to reduce
  overhead.

● Done. Here's the summary:

  8 commits implementing all 7 UI/UX improvements:
  1. Unified container frame with "BotGlue" title and model footer
  2. Labeled horizontal dividers ("Recent prompts", "Prompt")
  3. Autocomplete suppression in all panels
  4. Model tags as right-aligned extmarks
  5. UTF-8 safe prompt truncation
  6. Fuzzy match highlights via matchfuzzypos
  7. Filter placeholder + prompt placeholder + WinLeave auto-close

  71 tests, all green. make pr-ready passes. Code review found and fixed 2 issues (namespace caching, placeholder restore on filter
  clear).

















































